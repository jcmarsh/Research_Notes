* <2014-07-13 Sun 11:16> First go
Already installed cFE and OSAL on my laptop. I have the associated guides, and can "run" cFE, but I don't know what it is actually doing or how to make a simple program. Maybe ping would be a good first step? Or a printf type deal?
** OSAL
What is OSAL? Or, perhaps a better starting place, what is FreeRTOS?
** FreeRTOS
A real time operating system for embedded systems. Real time means that the system can make concrete guarantees about when tasks will be completed, unlike commodity OSes which are best effort.
Why am I writting this like a lecture?
The interface between the hardware and the user's applications.
** OSAL again.
Where an RTOS provides a unified abstraction for a large set of hardware, OSAL provides a unified abstraction for a large set of RTOSes. Why so many layers?

Three APIs within OSAL; OS, File and Interrupt / Exeception. One of the best ways to understand a system is through the APIs it presents.
** OSAL OS API
*** Misc
*** Queue
*** Semaphore and Mutex
*** Task
** OSAL File API
*** File
*** Directory
*** Disk
** OSAL Interrupt / Exception API
*** Interrupt
*** Exception
*** FPU Exception
* <2014-07-16 Wed 18:59> Eh? How goes it?
Looks like there is already a sample library and app.
Library doesn't seem to bad... Needs an init function which is then specified in the Makefile.
Surprisingly the application has a lot more going on.
** for_build
Yeah, the Makefile
** mission_inc
sample_app_prefids.h - Performance IDs? Maybe the priority?
Why not for libraries? Library calls probably have the priority of the calling function application. They do have an initialize call... I wonder if just a single instance runs (more like a service than a library).
** platform_inc
sample_app_msgids.h - Message IDs... just few defines with 16 bit values. Curious to see how these are used for (pressumable) auto generating some message passing code.
** src
sample_app_events.h - Event IDs... so I guess it is safe to assume that events (software interrupts? signals?) are supported.
sample_app_msg.h - Data types for the different message types. Does not tie in the message ids.
sample_app_version.h - as one would assume.
sample_app.h - Main header.
What is SAMPLE_PIPE_DEPTH?
Defines a main method, which has to be specified in the Makefile (like the init for the library). 
sample_app_main.c - Finally, the program. 
Hmm... this "pipe" thing seems important. Is it a queue in OSAL?
Also has a message pointer type... shared memory? Likely to reduce copying.
Event filters using the event ids.
Lots of cFE provided calls; program status, receive messages, logging, exit.
AppInit is the most interesting: calls to register for events / pipes.
Looks like the receive message call takes a pointer to a message pointer (which is global), and the main loop calls a processing function that assumes that pointer has been updated. 
** Running
There is a run script: build/pc-linux/exe/cfe_es_startup.scr which lists the library's / apps to run with a cryptic bit of options.
* <2014-07-21 Mon 07:36> Actual
Today I want to get my own example up and running. Then maybe look into running on the dev board? Or interfacing with Stage.
** Notes from Alan Cudmore Meeting
The SAM7 board (and the GomSpace board) pose some problems. The SAM7 does not have a file system library, necesitating a EEPROM fs and an odd loading system. A static loader, of sorts... not really sure. RAM on the GomSpace is only 2MB, which will be tight. OSAL is still being ported to FreeRTOS.
GomSpace uses Waf (http://en.wikipedia.org/wiki/Waf), a python based build system.
cFE is designed to deal with multiple processors in a system, not a complication for us.
Uses simplified pub/sub, channels (called pipes?) set up in the init functions of apps. 0 copy is available... default copies messages.
Each app has priority, 0 is highest.
Not clear on the exact interplay between libs and apps. Libs are not the same as the standard definitions... more similar to a driver. They have an init function, and may keep persistent state. But their (other) functions are only run when called by an app.
I do not quite understand the preemption model.. is there preemption? Then what is available in libs to ensure mutual exclusion (right phrase?)? What about interrupts?
The exe directory seems interesting, lots of ugly platform details. What is the table abstraction all about?
** Producer App, Consumer App, Sharing Lib
From my notes above, it would seem that a good example to flesh everything out would be to create a shared memory library, which is then exercised using a producer and consumer applications.
Now, how to go about that?
*** Library, v0.1
Needs to allocate memory in init, write / read methods, protection?
**** fsw/for_build
Pretty straight forward, just change target name, entry point, and object file name.
**** fsw/public_inc
Again, straight forward, just the function definitions for exported functions. Not sure how the comment format works though.
Need to work on some other stuff... Hopefully back to this in a bit.
**** fsw/src
The meat of it. Changed the version in share_lib_version.h.
Changed some names... actually to the implementation here in share_lib_main.c.
Simple implementation is done... build?
*** Build
Top level, run:
  . ./setvars.sh
Go to build/pc-linux
  make
  make install
And no share lib.
**** build/pc-linux/Makefile
add the sample library in the apps target
  apps::
    $(MAKE) -C share_lib
And cleanapps
  cleanapps ::
    $(MAKE) -C share_lib clean
And 
  installapps ::
    $(MAKE) -C share_lib install
And
  dependapps::
    $(MAKE) -C share_lib depend
What does that last one do?
No share_lib directory?
The pc-linux directory has Makefiles... are these copied from the apps source? Am I missing something here?
One change to the Makefile: share_lib.o to share_lib_main.o
And have to copy the share_lib.h file into apps/inc/
Warnings about redefinitions... prefix global data with "share"
Looks like it built! Now how about running?
*** Running
Will have to wait... time to sleep.
* <2014-07-22 Tue 07:49> Running?
Building is a mess. There must be some utils or something to make it easier. Or maybe they don't bother since each platform might need a different system.
Either way, to run my example I need write and build two applications as well as figure out the runscripts.
First I'm going to change the library to print more informative statements so that I can test with just one application at first.
Hmm... Is that a big difference between apps and libs?- Apps must communicate with other apps via messages, but can call functions in libraries?
** pro_app
The producer. Will write to the share library.
*** for_build
Makefile - change APPTARGET, ENTRY_PT, OBJS (changed for the makefile in build/pc-linux/?). Likely need to copy to build dirs.
*** mission_inc
pro_app_perfids.h - Performance IDs? Set to 91. Alright then. I wonder if any analysis is performed.
*** platform_inc
pro_app_msgids.h - There must be some reasoning for the id numbers. Didn't I see a utility about this? I'm just going to keep the command id. Not sure what "HK" stands for.
*** src
pro_app_events.h - not sure what events I need here; all seem important.
pro_app.h - Should look into the headers here. And PIPE_DEPTH.
* <2014-08-05 Tue 15:27> Back to it.
Test out / run the producer app? Does it build?
* <2014-08-06 Wed 09:36> 
Can't build... not finding pro_app_perfids.h
Manually copying... should automate... why isn't it? Probably is.
Should copy mission_inc, then platform_inc
Also, check for message id conflicts?
Alright, start script.
Have to manually copy the new .so? I am definately missing out on something here.
* <2014-08-07 Thu 08:51> It Builds
But does nothing. Because I have not told it to do anything. Would be great if there was a way to send test messages.
** Adding a new data type to send.
Add a new message id
* <2014-08-11 Mon 11:08> Starting over
This time, smrter. D'oh! Smarter.
And recorded as a tutorial.
Untar> tar -xvf cFE-6.3.2-OSS-release.tar 
Made a script make this go faster. But that took all afternoon.

* <2014-08-12 Tue 11:28> Make making easier
Make sure osal is already installed.
> . ./setvars
> cd build/pc-linux
Edit Makefile, adding sim_sensor_app to the same rules as sample_app. And:
apps:: copy_apps
        $(MAKE) -C sample_lib
        $(MAKE) -C sample_app
        $(MAKE) -C sim_sensor_app

copy_apps::
        rm -rf sim_sensor_app
        mkdir sim_sensor_app
        cp ../../apps/sim_sensor_app/fsw/for_build/* ./sim_sensor_app/
        cp ../../apps/sim_sensor_app/fsw/platform_inc/* ./inc/
        cp ../../apps/sim_sensor_app/fsw/mission_inc/* ../mission_inc/

> cd ..; make; make install

Now to run, edit cfe_es_startup.scr, add:
CFE_APP, /cf/sim_sensor_app.so,   SIM_SENSOR_AppMain,  SIM_SENSOR_APP,   50,  16384, 0x0, 0;
> sudo core-linux.bin


