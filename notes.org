* Wed Jul 25 06:46:18 PDT 2012
Edit hijack.c to compile without the following includes (comment out error lines)

Where the bloody hell is pte_t defined, and why is it throwing errors before I even change anything?
	pte_t is in linux/arch/x86/ and has two defs, depending on if the system is 32 or 64 bit.
	if 32, then it has two unsigned longs: pte and pte_low, 32 bits each. 64 has one unsigned long (64 bits)
	paddr_t is also an unsigned long

FIXME Topics thus far: PTE IPC.H MMAP.H HW_INTS.H

How about ipc.h? Just a function to init.
asm_init_defs.h seems like an obvious place that changes will need to be made. Perhaps split into two .h files.

* Mon Jul 30 14:56:50 PDT 2012
Okay, I have started to look into some the assemble (ipc.S and kern_entry.S), and things are going slowly.
** Good things to know:
Composite uses the AT&T style format
  Compile with "as" instead of "nasm"
  Registers are prefixed with %
  Source operand comes before the destination
** It is all going to have to change to make the switch to x86_64 
* Tue Jul 31 08:01:52 PDT 2012
Assembly is on the back burner. Will try today to get a basic build (which will just fail out).
I will start committing changes to my local git.
** Changed the struct spd_location in spd.h to use long instead of int, to eliminate warnings about shifting more than the size of a type... ints are always 4 bytes while longs changed from 4 to 8. This will likely be a recurring source of problems.
There is a similar problem with #define SHARED_REGION_START in kernel/include/shared/consts.h
Currently it is set to (1<<30), which corresponds to 1 gb? Or the location of the 1st gb in the pagetable?
If it is set to something greater than (1<<31) then I get warnings that the left shifts are wider than the type
  Things like current->mm must be ints instead of longs
** I need to calculate how to address the first gb in the 64 bit linux
How is it currently working? Is composite using pgtable-2level_types.h or pgtable-3level_types.h?
  pgtable-2level_types.h, since when pte_high does not exist.
** I made some changed to consts.h, set them to what I think will be the correct values and added some casts

** F-ing unions man. Now I know what they are. And that I can safely just use pte_t->pte instead of pte_t->pte_low (since both pte and pte_low are pteval_t)
As such, I have been able to uncomment some PTE code.

** Tomorrow I should check to see if I have actually cleaned up all of the PTE stuff, and ask Gabe about consts.h.

* Fri Aug  3 09:13:54 EDT 2012
Notes on creating my presentation on low level embedded OSes.
** What is the domain?
Sensor network
Smart Home
"Internet of Things"

** What constraints impact design decisions?
Extreme hardware constraints
 No disk
 kBs of ROM, Bytes of RAM
 Clock speed in Mhz
 As little power as possible

TinyOS
Component based, small granularity
Split - phase execution: events (interrupts) and tasks ()
nesC: restricted c to do compile time checking and inlining

EMERALDS

CONTIKI
Dynamic code updates

** What are the common abstractions?
Events
Threads? At user level, because "states are hard"
Message passing

* Mon Aug  6 11:26:30 PDT 2012
Not sure where to start. I need to ask Gabe how to go about actually running the core program (just hijack I guess).
Can not insert the cos.ko module, because of all of its missing links: "insmod: error inserting 'cos.ko': -1 Unknown symbol in module" which I think result from all of the commented out includes. I will start adding them back in one at a time.
#include "../../../kernel/include/spd.h"
  No problems...
#include "../../../kernel/include/ipc.h"    
  Also no problems... I am suspicious.
#include "../../../kernel/include/thread.h"   
  It's too quite; no problems...
#include "../../../kernel/include/measurement.h"
  No Problems.
#include "../../../kernel/include/mmap.h"    
  NO PROBLEMS.
#include "./hw_ints.h"
  Hmm... still nothing wrong. Maybe things will be okay after all.
#include "./kconfig_checks.h"      
  Of course this has problems. I will just comment out.

* Tue Aug  7 12:55:29 EDT 2012
Where do I go from here? Back to assembly? Hmmm... maybe some of the other included files from the module Makefile.
hw_ints.o
About 7 of the following: warning: cast to pointer from integer of different size
On lines like: cos_default_sysenter_addr = (void*)se_addr; 
void* are now 64 bit, se_addr was declared as an int. Change to long?
se_addr is used in the previous line: rdmsr(MSR_IA32_SYSENTER_EIP, se_addr, trash);     
rdmsr is in arch/x86/include/asm/msr.h

* Thu Aug  9 11:02:38 EDT 2012
Switching to the org-mode format. Super Sweet. Now for actual work.

** chk_offsets.c
Gabe made this file so that at compile time we could have some checks in place to make sure that we are using the correct offsets into structs.
He filled out the first few for thd_invocation_frame.
I finally found the next struct: usr_inv_cap.
Errors compiling... just need to #include <stddef.h> 
Actually, no. The problem is that sizeof can not be used in a #if, and offsetof uses sizeof.
I don't know why the size can't be known to the preprocessor, but deems the breaks.

** Write a piece of assembly to make system calls in x86_64
Can compile from c to assembly with: gcc -S -m64 file.c
Must compile, and then link
> as -o hello.o hello.S
> ld -o hello hello.o  

* Mon Aug 13 13:31:50 EDT 2012
** Check for struct offsets
In chk_offsets.*
Will have to be done at runtime, during initialization because of sizeof problem.
I'm not sure if I can use "assert()", since code may not be able to call out to linux. Maybe "perror()"?
"assert" is used in the test cases... so I'm guessing it is okay to use. Actually, it used in kernel too.
Okay, Gabe actual wrote his own assert (in kernel/include/debug.h). The test programs in platform/tests/ use the regular c assert.
I will use Gabe's.
I don't know what to do with syscall integer offsets... since they are bitshift amounts for an int
I don't think that chk_offsets needs a header file. Ask Gabe how he prefers.
Now where should I call the function from? Added call to check_offsets() in hijack.c
** Syscall assembly
I don't know what I'm doing.
Trying to figure out ipc.S. <asm/asm-offsets.h> is generated... I'm not sure when. But it isn't in lxr.linux.no
I couldn't find where "call cos_syscall_upcall_cont" went. Turns out it is in kernel/inv.c, so you can call c from assembly. Makes sense I suppose.
Crap... there is a lot that is going to have to be changed in inv.c
Look into pt_regs, and figure out if it is actually being defined by /kernel/include/shared/consts.h
A lot here... need to focus.
What the heck are these "brands"? "cos_syscall_brand"?
These are all system calls provided by Composite (see inv.c cos_syscall_tbl). How can I test that? Testing framework indeed.
** Syscall Testing Framework
How can I actually do this?
Perhaps later...
** adding ../../../kernel/inv.o to platform/linux/module/Makefile
Several compile warnings, tons of linker warnings.
Most compiler: "warning: cast to pointer from integer of different size", will change casts?
kernel/inv.c:1637 - easy fix, printk statement, changed format from %x to %lx and cast to an unsigned long
kernel/inv.c:1845 - (unsigned int)(user_gi->data), changed cast to unsigned long. user_gi is a gather_item, defined in kernel/include/shared/cos_types.h, and data is a void *
kernel/inv.c:1875 - another printk, this time looking at a sizeof (which returns a 'long unsigned int'???). printk has a format just for size_t: %zd (or %zx)
kernel/inv.c:2170 - 

* Tue Aug 14 13:50:57 EDT 2012
** Continue adding ../../../kernel/inv.o to platform/linux/module/Makefile
kernel/inv.c:2170 - type defined in cos_types (see heading below). "~0UL" means 2's complement of the unsigned long 0. A u32_t is assigned that value. So I will just change to "~0U".
kernel/inv.c:3444 - "spd" defined in kernel/include/spd.h. Just another "pointers are now 64bit" problem. Changed cast.
kernel/inv.c:3445, 3447, 3449 - Same as above. 3449 also required a format change to %zx for printk.
Currently at 51 undefined labels
** COS_BASE_TYPES in /kernel/include/shared/cos_types.h will need to be examined. Maybe not.
As far as I can tell, they should be fine. A "long long" ends up being 64 bits on both architectures. The others are fine as well.
The question is if their usage should be changed. That can be decided later.
** adding ../../../kernel/thread.o to platform/linux/module/Makefile
No problems, currently at 47 undefined labels
** adding ../../../kernel/spd.o to platform/linux/module/Makefile
kernel/spd.c:490, 506, 687 - printk and unsigned int problem, change to %zx and unsigned long
Currently at 20 undefined labels
** adding a bunch more, no problems
../../../kernel/measurement.o - currently at 15 undefined labels
../../../kernel/page_pool.o - currently at 12 undefined labels
../../../kernel/mmap.o - currently at 10 undefined labels
../../../kernel/ring_buff.o - currently at 8 undefined labels
hw_ints.o - currently at 16 undefined labels
Only ones left are kern_entry.o and ipc.o, which are the two big .S files
** kern_entry.S is only 240 lines... so let's start there.
kern_entry.S references "entry.S", which I am assuming is entry_32.S in the linux source. (lxr.linux.no is down! Had to find it myself!)
Fuck.
Seems like a bunch of the beginning stuff isn't needed. Offsets of some sort, but only ORIG_EAX is used.
Couldn't find the equivalent code in entry_64.S, turns out a look of it is defined in calling.h.

** grep, good to know
> make | grep "WARNING" | wc -l  -- Does not work. make warnings go to stderr
> make 2> errors.txt; wc -l errors.txt -- Does work.

* Tue Aug 15 09:34:01 EDT 2012
Time to tackle kern_entry. Since it is currently based off of entry_32.S in the linux source, I will base the new one off of entry_64.S.
To start, I'm just copying kern_entry.S to my new file, kern_entry64.S, and will try to walk through it.
I don't know of a good way to test it....
** includes and define
I didn't look into any of the <> includes. 
"asym_exec_dom.h" is only used in hijack.c, so will comment out.
"asm_ipc_defs.h" is used.
ASM_PAGE_MASK is not used. And I don't know what it does.
** From entry... labels? EBX             = 0x00
Just replaced the original with that in calling.h. calling.h also lays out the stack calling conventions.
** Setting up macros / defines? SAVE_ALL, RESTORE_ARGS etc.
I don't know if SAVE_ALL should be a #define or a .macro. For 32, it was a .macro, but Gabe changed it.
I'll try SAVE_ALL as a #define
What is this "CFI_REL_OFFSET"? - An assembly directive... saves register to an offset of the CFA register. I don't know what the CFA register is.
I will not use it, since Gabe didn't seem to use any directives. Maybe they are not available in composite?
They are "Call Frame Information" directives that I am seeing everywhere. I will assume that they are safe to ignore.
LOAD_ARGS vs RESTORE_ARGS? - load seems to be able to take an arbitrary offset, doesn't mess with CFI
** Compiling / Testing
I'm still a bit foggy on what the purpose of these calls are... but I know what they should do, so I'll try to test them.
Maybe just write a bit of code that calls them, and then see what happens in gdb?
*** Compiling
Just trying to compile, and having troubles. Doesn't like the '\'s, and the #define functions... Maybe Gabe uses a different compiler.
Maybe the #defines are not being pre-processed out.
Well, I can't compile Gabe's code anyways. Maybe gcc? gas?
Use gcc. I need to figure out how to get all of the includes working. Makefile time (synonymous with "shoot me in the head time").
What the heck is going on with these makefiles?
Soo... I don't... I hate make. And it's a problem with trying to include kernel headers. I'm just going to get rid of the includes; I don't think I need any of them yet.
gcc vs as problem: I'm getting this error, but only with gcc: (.text+0x20): undefined reference to `main'
gcc just needs a main label, which is declare globl. See my nifty hello world program.
*** Testing
Alright, finally, I can test those save and load #defines. But how?
Put a value into a clobbered reg (%r8 for example), call save, clobber it, restore and check.
My test program does not work.... programmer error.

* Thu Aug 16 11:01:52 EDT 2012
** Testing my stack manipulation calls
*** jmp problem, actually addressing incorrectly
There is an error in my program, the 'jmp' command is not doing what I expected it to. In fact, it is not jumping.
I'm going to make a minimal version to test it, and if that does no elucidate the issue, I can post to StackOverflow.
The problem is not with 'jmp', but with how I am setting up the data. Printing does not stop with the first line.
Actually, the .data section was perfectly fine. The problem was with addressing the labels. "$label" gives you the address, which is fine for the string location, but gives you a giant number for the length value. Use "label" to place the value at that address (see jmp_test.S for an example).
*** Next problem... SAVE_ALL and RESTORE_ALL do not work.
Not sure why.
Great. Now I have confirmed with GDB that SAVE_ALL and RESTORE_ALL don't work. Maybe they aren't being preprocessed?
Maybe the #defines are being treated as comments?
Apparently those '\'s were very important. And they can not have any characters after them.
Now the registers seem to be saved, but maybe not read back correctly.
The stack point (%rsp) is not changing by the amount that I calculated it should be... I must have my commands wrong again. Time for another test program.
*** fuck.
First example program works okay. In GDB make sure to do the 'tui reg general' command right before stepping through.
Looks like my syntax is correct... I am using subq correctly.
What the bloody hell is going on here? I'm just going to get rid of the #define for a moment and copy and paste it all.
Works fine with the code just expanded in... Something must be wrong with how the defines are done.
They are only moving the stack 6*8 bytes, so only SAVE_REST is running?
I replaced SAVE_ALL with:
SAVE_ARGS
SAVE_REST
And it just bloody skips over SAVE_ARGS. What gives?
It was a missing '\'.

** What is next?
Moved the #defines to a header, calling.h

* Fri Aug 17 13:21:03 EDT 2012
Continuing to port kern_entry.S to x86_64. Will likely have to look things up line by line.
I neglected to bring my charger, so I'm going to try to write it blind here (no compiling)
New code starts at 84. I will skip lines which are comments / whitespace

| Line # | original                                   | x86_64       | Notes                                                                    |
|--------+--------------------------------------------+--------------+--------------------------------------------------------------------------|
|     84 | .data                                      | .data        |                                                                          |
|     85 | .align 16                                  | .align 16    | I don't know why, but from what I've read it should be fine              |
|     93 | .text                                      | .text        |                                                                          |
|     94 | ALIGN                                      | ?            | These are defined in the generated asm_offsets.h                         |
|     95 | ENTRY(sysenter_interposition_entry)        | ?            | Not clear. asm-offsets_64.c does the actual gen. gets the                |
|        |                                            |              | offset into a struct? Is align set to that?                              |
|     96 | movl TSS_sysenter_sp0(%esp),%esp           |              | No idea. set sp to the TSS?                                              |
|    110 | cmpl $((1<<COS_CAPABILITY_OFFSET)-1), %eax | same? cmpq?  | Check if it is a cap_inv                                                 |
|    111 | ja composite_call_ipc                      | same         | jump if above (cap_inv). Will need ipc.S (has the label)                 |
|    112 | je composite_ret_ip                        | same         | see above                                                                |
|    114 | cmpl $((1<<COS_SYSCALL_OFFSET)-1), %eax    | same? cmpq   | see 110                                                                  |
|    115 | ja cos_syscall_thunk                       | same         | was a composite syscall. label in same file                              |
|    117 | SAVE_ALL                                   | same         | Implemented! In this case it is a linux syscall                          |
|    118 | pushl %eax                                 | same? pushq? | Need to check about this long vs quad thing. l = 4, q = 8?               |
|    119 | call hijack_syscall_monitor                | same         |                                                                          |
|    120 | addl $4, %esp                              | addq? 0  4 8 | I need to see why 4 is added (pushl $0 in SAVE_ALL?)                     |
|    121 | RESTORE_REGS                               | RESTORE_ALL  | His defines have different semantics than mine                           |
|    122 | normal_syscall:                            | ?            | Not used anywhere                                                        |
|    125 | pushl $0                                   | same?        | space for get_TSS (in hijack.c) to return the tss (see 130)              |
|    126 | SAVE_ALL                                   | same         |                                                                          |
|    127 | movl %esp, %eax                            | same? movq   | This is how we pass the struct pt_regs* to get_TSS                       |
|        |                                            |              | Need to check pt_regs!                                                   |
|    128 | call get_TSS                               | same         | double check hijack.c                                                    |
|    129 | RESTORE_REGS                               | RESTORE_ALL  |                                                                          |
|    130 | popl %esp                                  | popq?        | get the TSS pointer                                                      |
|    131 | jmp *(cos_default_sysenter_addr)           | ?            | Can't find label. jmp * may not be supported.                            |
|    136 | cos_syscall_thunk                          |              | Loads something into %fs before calling composite_make_sycall (in ipc.S) |
|        |                                            |              | Do we even have %fs?                                                     |

* Fri Aug 24 15:14:05 EDT 2012
Time to start getting at the meat of kern_entry.S
** Trying out my notes from a week ago.
Wow, I didn't get very far, did I? And it is all questionable.
** What about ipc.S
Check on pushl vs. pushq, and cmpl vs cmpq.
* Sat Aug 25 12:45:48 EDT 2012
** Working on ipc.S
Will use the suffix 'q' instead of 'l'. This should specify quadword (64bit) operations. Should be fine.
As far as I can tell, I should be fine just changing commands to 64bit by setting the suffix to 'q',
and updating the registers.
I need to be on the lookout for instructions that may have side-effects.
It is not necessary to take advantage of the extra r8-r15 registers.
** Memory Segmentation
It looks like I'm going to need to understand this for the next two lines.
There are a few special memory segment registers, such as FS, GS, SS (stack segment).
Memory Segmentation is an early (286ish) way of providing memory protection. Each process is given a "segment" of the memory (a range of valid address) which it can then use.
This was replaced by Virtual Memory, which maps a process' memory to actual memory transparently.
Segmentation was kept around, but not really used (set base to 0, limit to 2^32). 
x86_64 removed this backwards compatibility, but apparently added it back in later for some processors?
*** movl $(__USER_DS), %edx ;\ 
__USER_DS is the user level data segment
*** movl %edx, %fs          ;\ 
What is "%fs"? A segment register apparently.
Can't move constants into a segmentation register!

** segment.h
asm\segment.h is where __USER_DS is defined. For 32bit it is (15 * 8 + 3) and for 64bit it is (5 * 8 + 3).
The difference comes from the structure of the GDT (Global Descriptor Table, a per-process (?) structure that keeps tracks of things like, well, memory segments).
*** almost sent this to Gabe... will track him down later.
This chunk of code is used to transition from Composite kernel mode to Composite user mode, for example in order to complete a Composite system call.
"pushl %edx" and the following "popl %edx" just preserves the value in %edx.Â 
"movl $(__USER_DS), %edx ---- This is where I get confused. __USER_DS (defined by linux in asm/segment.h) is the location in the GDT the address for the the user data segment starts at. Combined with the next line we see that this is then moved into %fs, a segment register.

But the GDT is a linux data structure. Wouldn't it just be the same for everything in Composite since Composite is a process inside of Linux? So the purpose would be to restore %fs? Why wouldn't %fs be clobbered some times and not others? What is changing %fs in the first place?
Actually... maybe not a linux data structure... I give up.

* Mon Aug 27 10:24:09 EDT 2012
** RET_TO_USER
I am spending way too long on these five lines of code. I can not seem to find much use of %fs in the x86_64 linux code, so I'm just going to try ignoring it for now. Hopefully it will not bite me in the ass.
#define RET_TO_USER .... will now be #define RET_TO_USER RET_TO_USER_NOSEG
** THD_REGS
I'm going to write some example code to test if, as the comment says, the value really is that offsetof. /kernel/include/thread.h has the struct thread.
Tested in both 64 and 32, offset is 8 in both (I am sane!)
** composite_call_ipc
cdecl? This is the function calling convention. What is it for x86_64? Do I need to change the registers used?
I'm looking into the System V AMD64 ABI, which should be what is being used. Not certain how this is actually used.
The assembly is calling a c function in /kernel/inv.c, so it must be for that... why assembly at all?
* Tue Aug 28 09:46:24 EDT 2012
Still working on this crap. I think I have it figured out:
Wait... no I don't. But here goes anyways:
inv.c has the c implementations of the composite syscalls, each labeled COS_SYSCALL
COS_SYSCALL is a macro for __attribute__((regparm(0))), which specifies that all of the arguments will be on the stack.
ipc.S calls the composite syscalls in inv.c, after setting up the registers and stack correctly
kern_entry.S calls the functions in ipc.S (See note about ENTRY below)
hijack.c sets up (through hw_ints.c/h) the interposition of the composite syscalls
Do do this, hijack.c messes with the MSR, which I will need to revisit.
cos_component.h has a comment describing the composite syscall process.
I think that cos_component is compiled in with each component, which is how it can access a components id...
 - Don't actually know... check into this
** ENTRY
#define ENTRY(x)    .text; .align 32; .proc x; .globl x; x: 
.text
.align 32 - data will be aligned % 32 bytes
.proc x - gnu as ignores this directive. 
.globl x - x has global scope
x: - a label to jump to

* Thu Aug 30 14:41:24 EDT 2012
I need to figure out the semantics of push. Hopefully they have remained the same. Then figure out the component id thing
** push, pop
First decrement, then write. Pop is read, then increment.
** Taking a new tack!
Talked to Gabe, and he has me pointed in a new direction.
I need to start with making a small module.
Then, the module should interpose itself in a similar to seen in hw_ints.c
Next, support composite invocations.

* <2012-08-31 Fri 08:19> Module
I have a "Hello World" module now in /JamesTest/newModule
** Interpose on system calls
hijack.c defines the init and cleanup functions, asym_exec_dom_init and asym_exec_dom_exit.
I'm making a new module that only tries to interpose on syscalls. hw_int_init and hw_int_override_sysenter.
** /proc/aed
What is make_proc_aed?
/proc/ is a linux pseudo-file system for kernel data structures. Each process has a folder, named /proc/[pid]
That's pretty cool. Each process has a ton of files such as "sched" and "maps" which have a lot of info about running process
There is even a symbolic link, cwd, which is that processes current working directory!
Back to task: I have no idea... emailing Gabe.
** hw_int_init
Not a light function. Will need to understand what an idt is.
*** IDT - Interrupt Description Table
This makes sense, just a array of interrupt vectors. Their index is the interrupt number.
Lowest 32 are reserved for the cpu. Up to 256.
I think 80 was the old syscall one: "int x80"... wait... is that 80 in hex then? Doesn't matter, now there is sysenter
There is a register that holds the base address of the array, idtr, which is accessed with sidt and lidt instructions.
SIDT - stores from the idt to the location in the first operand.
LIDT - loads from the operand into the idt
Okay, I'll just try to read the location of the idt.

* <2012-09-02 Sun 14:15> Syscall Interposition
Alright, let's interpose on syscalls! Figure out idtr... 8 bytes address, 2 limit
** inline assembly
The format for inline assembly is:
  asm("instruction template" : output : input : clobbered registers);
So you can use c variables inside the assembly instruction. Kinda like printf()
%0 denotes the first value, %1 the 2nd, and so on.
Because of this formatting, registers need to be referenced like: %%rax, instead of %rax
** /arch/x86/include/asm/desc_defs.h
This is where we see "struct desc_struct" defined. For x86_32 there is only one type
For x86_64 there are 2, all 16 byte: Gate (interrupt?) and LDT / TSS
I'm not sure which I should use.
** attribute __packed__ ?
** Working version?
I think that I have it working, but I could be completely wrong. My module prints out the address of the idt,
which looks like: ffffffff816d4000
That seems like a suspicious number. I'll try to read the first entry, and see what happens.
Well, I can print out the address of the first interrupt (or its offset?). And the reserved bits are infact 0.

* <2012-09-03 Mon 12:04>
Apparently that is not the way to go about it. I need to look into syscall and sysret. 
Composite just writes to the Model Specific Register to change the system call entry address.

* <2012-09-04 Tue 11:04> Syscall Interposition
Yesterday was a wash. Trying again.
** wrmsr(MSR_IA32_SYSENTER_EIP, (int)handler, 0);
I need to find where this stuff is actually defined. kernel.h is included, which in turn includes a ton of headers.
There is actually a /arch/x86/include/asm/msr.h
*** wrmsr
A macro for the wrmsr instruction in x86. MSRs are 64 bit. wrmsr writes to the register specified by ECX.
EDX becomes the high order bits, and EAX the low. For 64bit, the instruction is the same; all regs are treated as 32bit.
*** MSR_IA32_SYSENTER_EIP
This is and architectual register listed in the Intel docs. Actually defined in /arch/x86/include/asm/msr-index.h
It looks like I am not going to have to change anything, given the instruction semantics and the way the linux headers handle it.
** Testing it?
Am I just going to brick my system?
Okay, need to write the actual handler. Current one is in kern_entry.S
Made a very simple on in kern_entry64.S... I don't know how to compile it all together.
Where is cos_default_sysenter_addr defined?
** cos_default_sysenter_addr
This, is of course, first read from the machine specific register. I need to test this first.
In my kern_entry code I can perhaps jump to it.
Also, I may need to change the wrmsr code so that it uses both of the address args, since the address should now be 64bit.
** Testing
So... the value read was 0. That seems incorrect.
Maybe this whole syscall vs. sysenter thing is to blame.
** syscall vs. sysenter
syscall/sysret is the new AMD format (used in x86_64).
sysenter/sysexit is the Intel format.
Switch to MSR_LSTAR (or should it be MSR_STAR?)
The address read is: 81002aa0:ffffffff 
Something is probably wrong with the low order bits.
Printed them out backwards, ffffffff is probably the high order bits.
** Writting to it.
This may be bad. Just try writting to it and resetting.
Segfaulted, had not changed back to MSR_LSTAR (from MSR_STAR). At least it didn't brick.
Well, can't remove the module. Back a snapshot anyways.
Can read from it, and write the same value back.
Next I tried to write a new value, and then change it back soon after. Bricked.
I'm going to try reading it with the assembly instruction instead of the linux macro.
I got the same address with the assembly version.
** msr-tools
There is a package (sudo apt-get msr-tools) that has a tool to read MSRs. rdmsr.
Sanity check, here I come.
Well, except the tool doesn't work... I need to figure out if I configured the kernel with CONFIG_X86_MSR
** On infrequent, rare occasions I get this odd feeling that perhaps I actually do know what I am doing.
My kernel was not configured with CONFIG_X86_MSR, so I set it to =m, and remade my kernel.
Only took one try.
** sudo rdmsr 0xc0000082 
ffffffff81002aa0
That, you may notice, is the value my code was originally producing. That much is encouraging.
By why didn't writing work? It's late; I'm going home.
** wrmsr
This time I'm going to write to the msr, but will not try to printk.
The thinking is that printk might be triggering a syscall. Results should be interesting.
Alright, snapshot and give it a go.
Holy crap, it worked!
** kern_entry64.S
Let's see if I can hook in, and not brick the system.
Spent a ton of time trying to get it compiling correctly.
Should have read kernel make documentation to start with. But it links happily now.
obj-m := name.o // make a module named name
name-objs := file0.o file1.0... // name.ko is composed of these files.
Time to stop.

* <2012-09-05 Wed 16:16> Kernel Stack
Compiles and is happy. Time to try to write my syscall handling code.
Getting the casts correct. This low / high address thing is a pain.
Heck yeah! Can now interpose my code in the syscall path! Without bricking. Pretty easy actually.
** kern_entry64.S
Time to rewrite it.
*** movq TSS_sysenter_sp0(%rsp), %rsp
Set the stack pointer correctly?
TSS_sysenter_sp0 isn't in composite code, it's from linux. But only the x86_32 specific code.
It is where the TSS (Task State Structure) is offset iin the sysenter stack. Perhaps I should look at the syscall stack instead.
Gabe stopped by. He basically said "Don't Panic" and warned against "ladder anxiety (starcraft)".

* <2012-09-06 Thu 10:07> Kernel Stack
** Getting a Stack in the syscall
The TSS line is throwing me off. 
I'm going to check how linux goes about syscalls, specifically if I need to do anything to set up a stack.
Looks like syscall saves %rsp, and then reads the location of the kernel stack:
 movq    %rsp,PER_CPU_VAR(old_rsp)       
 movq    PER_CPU_VAR(kernel_stack),%rsp 
Actually, do I need the kernel stack? Can I just stay in the user space stack?
I'm going to try ignoring it. If problems occur, then I know where to start looking.
** composite_make_syscall
Ignoring "thunk" for now. Components will not be able to make linux calls.
In ipc64.S
Gabe's code uses %ecx, but syscall uses %rcx to store the old %rip (instruction pointer)
I should probably just save %rcx on the stack, and then restore it right before sysret.
Let's see if I actually have a stack available.
Wait, that won't work. The calling code will destroy %rcx. I should change the code in cos_component.h
Talked to Gabe, he helped with those %rsp related lines
*** swapgs
A x86_64 instruction that takes care of giving us the kernel segment instead of the user space one.
Needs to be called again to swap back before exiting call.
*** movq %rsp,PER_CPU_VAR(old_rsp); movq...
Now that we have access to the kernel data segment (swapgs), we can save the user stack pointer and get a handle on the kernels.
To get "old_rsp", you have to include <asm/percpu.h>, and use DEFINE_PER_CPU(unsigned long, old_rsp);
Maybe I should use a different name... I'm not sure if it will overwrite the old_rsp in the linux kernel.
Odd, you don't have to do the same to use kernel_stack...
*** Test the stack
I want to test that I can actually use the stack.
Added test_function to enter.c, will call it from kern_entry.S. This way I can printk.
The function looks funny because I have to make sure it doesn't get stuck in a loop on account of the syscalls made by printk.
Who bricks systems? This guy. Not funny looking enough I guess.
Twice. I'm doing something incorrectly.
It appears to be my code that pushes and pops to the stack. I'll try it in a user level program to see if it works.
Works in userland.
I'm an idiot. I was clobbering registers. Just used the SAVE_ALL and RESTORE_ALL macros from calling64.h
Bricked.
Bricked.
The problem is with trying to call my c test_function. I'm going to find an example for the syntax.
I'm just going to write a program that calls a function in another, and compile one with -S
Alright, that's done. I see how gcc does it. Now, hopefully it won't brick again.
That was it. Syntax is simply: call name_of_function
NOT: call *(name_of_function). That's what I get for just copying code.
Great, I can manipulate the kernel stack and call out to a c function!
*** Null system call
Back to this.
Will I have to ensure that swapgs is always called before returning?

* <2012-09-07 Fri 11:19> cos_syscall
Back at it.
I think that I'm just going to push %rcx to the stack (has the return ip) before continuing the syscall.
I need to do the whole stack swap thing anyways.
calling64.h now has macros for getting the kernel stack and switching back to user (takes care of the %rcx problem too).
Syscall code will be in ipc64.S, can now compile that in.
** Calling my syscall
Fucking syscalls, how do they work?
I need to have a piece of composite working so that it can actually try to make a syscall.
Compiling everything (is not the way to go but it) reveals some bugs I would need to deal with later.
*** cos_component.h:439: warning: cast from pointer to integer of different size
cos_argreg_buff_intern(char *buff, int sz) used COS_IN_ARGREG, which had a cast to an int from a function that returns a pointer.
Changed cast to unsigned long.
*** %rcx
I need to remember that I HAVE to change the calling conventions for composite syscalls and ipc. %rcx can not be used.
This is because syscall clobbers it. No way around that for now. Pushing it to the stack after the call is made obviously won't fix things.
*** c_stub.S
This is the next file to have problems while trying to compile.
It is a short file, but I'm not going to try to convert it yet, since it is used only for ipc (as far as I can tell).
Putting into Todo. Time to find a better way to invoke my syscalls.
** Calling my syscall, less distracted version
Well, there are a bunch of examples in src/components/implementation
I'm going to make a new one in src/components/implementation/no_interface/ ... since I don't care about interfaces yet
I should make the hello component in my 32 bit verson first.
* <2012-09-08 Sat 15:15>
I forgot that when I built that kernel (32 bit), I neglected to build any networking drivers.
I should have rebulit the kernel, but instead I just restart the machine when I need to get it only (which shouldn't be often).
Anyways, it's too complicated to try and get any of the simple examples working. The complicated ones work great, but the simple Hello World one is deprecated.
I should be able to build a much simpler one. I just need to take care of cos_component.h.
** cos_component.h
I don't understand the clobber list Gabe has. Just clobber everything?
In x86_64, syscall will clobber %r11 (for rflags) and %rcx (for the old instruction pointer).
Just like in x86_32, %rax specifies the syscall and is used for the return value.
I am only putting %r11 and %rcx in the clobber list. I guess it wouldn't hurt to put more.

* <2012-09-09 Sun 17:20>
Time to get something compiling and working.

* <2012-09-10 Mon 12:57> cos_syscall
Great, lots of work done yesterday.
I have some code almost building (just a null syscall)
** cos_component_information
Holds information about the component I take it. I guess I should fake this for now, since I'm not really building a component.
Defined in kernel/include/shared/cos_types.h with many of the core data structures.
cos_comp_info is external to cos_component.h. It must be a variable in the component that is making the call.
** cos_component.c
Shit! Didn't realize that there is a cos_component.c...
I don't quite get it. Looks like it would be something that one would extend or inherit from in an OO lang. But this is c.
How the bloody hell does this work? I don't see where cos_comp_info is created or stored. Except in cos_component.c, but I don't see the link between that and the components.
I'm just copying all of cos_component.c into my hello component. Seems reasonable.
Had to comment most of it out. Test run!
** Null syscall
It works, kinda. My test function was called... right before a trace was executed. I don't know why.
I think maybe the problem lies in saving %rcx and then bringing it back. I'll much with my COS_EXIT macro (is the code even reached?)
Bricked. Maybe I should try a different method of debugging.
Bricked. Sigh.
Do I ever do a return call?
I'm adding more test functions.
I don't see where in Gabe's code he calls a return instruction... but he does set interrupts again.
For fucks sakes. He does call it. At the end of a macro. But I read it as a comment to the code.
> sti ; sysexit
Please don't brick.
Merely a segfault!
** seg-what?
Dammit, I can't print in my "component" until I implement that functionality.
I don't actually know if that's true... could I build it with stdio?
I was able to include stdio.h. Right now I don't really have components, just programs that call into custom syscall code.
Will gdb help at all? A bit. Still confused.
The problem must be on returning, because the test functions are executing just fine. Maybe I am screwing up the stack?
** printing registers
I am trying to write a function in entry.c that will let me print out a register value.
Now I get a trace. Awesome.
Dammit, I know what I need to do: write an example program and see what the syntax looks like.
I am having trouble getting my damn example program linking.
Fixed. I was making it too complicated, trying to compile each piece separately.
First arguement is passed in %rdi, so I can just move the register I'm interested there first.
** %rip
Time to see if it is the %rip that is getting clobbered.
This is going to brick it, I think.
Bricked. I'm psychic.
No, wait, just stupid. Making calls to c code that prints in the syscall path will always brick.
%rip gets saved to %rcx with syscall, and restored from %rcx with sysret
As far as I can tell, That much of my code is working: The same address is printed.
Haha. If I try to print the register twice, I get something different. %rcx gets clobbered by my call to pring. Good to know.
It looks like the problem isn't with %rip, but with %rsp:
segfault at e17b6bdc ip 00000000004004d6 sp 00000000e17b6be0 error 6 in hello[400000+1000]
** %rsp
Can't get a handle on this.
Before call: %rsp > 0x7fffffffe1e0
Still before call (in header): 0x7fffffffe1d0
In the kernel: 0xffff88002ab53fd0
On segfault:                       0xffffe1d0
Okay, it looks like the stack pointer is losing high order bits:
Before:       7fff21fdb3e0
SegFault: 0000000021fdb3e0
All but the lowest 8 half bytes... so the lower 32bits.
What about the higher?
It's not the COS_ENTRY and COS_EXIT methods, they seem fine. It must be sysret
** sysret
It must be trying to return to 32bit mode, not 64bit.
sysretq
The problem was sysret had an "operand_size" of 32bits, so it was returning to compatability mode and thus ignoring the upper 32 bits.
I couldn't find anything about setting the operand_size (gcc flag? Is it in the GDT? Does the CS or SS have anything to do with it?).
Then I just tried sysretq on a whim, and it worked. I'm going home.
** housework
Back at it. Let's see if I can get print working.
But first a commit. And maybe I ought to do a quick backup.
Commited and backed up.
Battery at 85%. This is intense.
** %rax
Let's see if we actually have the correct value being passed in %rax.
It should specify the cos_syscall.
Great, first it is f8000, then 30, then 2d. Apparently %rax gets a bit clobbered.
f8000 might be right though. Should be d31, but shifted.
f8000 is correct, see /kernel/include/asm_ipc_defs.h
Great, it is now (removed the calls to c code for debugging)
And we are shifting it over correctly.
** call *cos_syscall_tbl(,%eax,4) 
Unfamiliar with the syntax.
cos_syscall_tbl is in /kernel/inv.c, an array of function pointers to the syscall functions.
I don't have the kernel yet... should I? I could add more junk into entry.c, but it's getting a bit ridiculous. It can't all be in a module.
So, I copied inv.c over, but I don't know how to go about compiling it.
There is not Makefile in the kernel folder. It does not appear to get built.
Of course, it is compiled into the composite module. I don't know why I thought it wouldn't be.
Compiling. And a segfault and trace.
Ha! I knew it, had to change the 4 to an 8!
NULL SYSCALL achieved! I'm out. Good night.

* <2012-09-11 Tue 10:00> cos_syscall
Time for the print syscall, which means I can get ride of my crappy code. But first I have to figure out how to pass arguments.
Shouldn't have to change the code in inc64.c
** calling conventions
The registers are all kinds of messed up. I need to figure out what the new calling conventions are.
Focus.
Added checks for IPC call and return, just for sanity's sake.
Confirmed that %rax has the right value, so the problem shouldn't be with the syscall array of function pointers.
Okay, I have confirmed that the problem is in fact with the register passing.
** registers
You can not specify the new registers (%r8-%r15).
I'm going to see if %rdx is actually passing the spd id
That would be a giant NO.
** %rdx / spd id
Alright, that works now. Just had to change which registers are used in cos_component64.h and in ipc64.S.
Actually, I'm not sure about the code in ipc64.S. It works without it, which makes me wonder if it is even needed.
I guess we'll see with the print syscall
** cos_print
I think I need Gabe on this one. The arguements are being passed just fine. The problem seems to be reading the user memory from the kernel.
Hmm.. Something is wrong with Gabe's code. I am able to read from the memory.
The problem is with writing to the memory, not the read. Will change to only read the string.

* <2012-09-12 Wed 08:53> IPC Call
Cos_syscalls work! At least print and null do. There may be some problems with registers for the 3 argument ones.
Now sure where to start with this. I do have a component... maybe I will try to do a fake IPC call.
I already have the code in kern_entry64.S set to notify when this happens.
I think that first I am going to have to actually implement the framework that components depend on. Then I can go about testing the IPC call.
** Support Components
There is a ton of stuff in cos_component.h. I'm not really sure what exactly I need.
ipc_walk_static_cap has a lot to it as well. Including the following structs: thd_invocation_frame, spd, invocation_cap
What about cos_loader?
Example of a component that invokes a capability? Ping pong example?
** pong
Very simple code. I will have to look into how the stubs are generated by gen_client_stub.c
I'm not quite understanding how gen_client_stub.c works. But it will have to be changed.
I must not be looking at code generated by gen_client_stub.c. Not going to worry about it. Seems that many stubs are hand written.
cos_loader.c is a beast. Has functions like create_invocation_cap.
I think I am going to have to take a different tack. Instead of re-writing pieces of everything, I need to only re-write the bits that are neccessary.
What is the minimum for pong? No, that is too much.
First the kernel side of the IPC path.
** ipc.S
kern_entry.S jumps right to ipc.S:composite_call_ipc on an IPC call

* <2012-09-16 Sun 17:11> Merge
I need to get cos_loader compiling. And merge my current code in with the current base.
** Merge
*** inv64.c
These are all of the syscalls. I can probably merge it easily back into inv64.c,
maybe with a few ifdefs for the inline assembly parts.
**** print_regs
This is obviously a problem. I also need to update the pt_regs struct.
Interesting, dietlibc uses a similarly named struct. Maybe they define a version for 64 bit.
dietlibc has many defined, but none for x86_64. Does it support x86_64? Current version says it does...
The new version supports x86_64, I should ask Gabe about upgrading.
*** ipc64.S

** cos_types.h
Let's looke at cos_types

* <2012-09-17 Mon 17:00> Merge
** dietlibc
I don't think that there is a need to actually upgrade to version 0.32 (current is 0.29).
Unless I find that composite code uses the arch. specific parts of dietlibc... hmmm... why use it at all? I should just ask Gabe.
Why would pt_regs be defined twice?
** pt_regs
This struct is used in debugging code it looks like. Architecture specific.
I need to figure out how to best change it.
Used in fault_regs.h, which uses enums from kernel/include/shared/cos_types.h
There is a lot that needs to be looked into.
It doesn't follow the pt_regs defined in /lib/dietlibc-0.29/include/sys/ptrace.h: it adds fs, gs, changes the names, and uses all longs.
I don't see why they have the same name to begin with anyways.
I'm not sure if my changes work.
** inv64.c
This needs to be merged.
So much stuff! Every syscall needs to be updated, and a bunch of helper functions.
Not to mention all of the structs.
*** struct thread
Defined in /kernel/include/thread.h
Shit. Changing this is going to effect ipc.S which makes assumptions about offsets.
May not matter, because the offset of struct regs does not change, just the regs themselves (any anthing after).
I'm lost.

* <2012-09-18 Tue 14:32> Merge
I need to get this taken care of today.
Maybe I should start back at the begining. Throw ifdefs around everything and have at it.
Should all of those syscalls use longs instead of ints?
** kern_entry
Trying to merge kern_entry.S files. Creating a new calling32.h.
Okay, it should work, but something is going wrong with the build.
I am getting undefined symbols that should be defined.
** make init
I'm just going to try to compile and see if I can get it all working.
*** c_stub.S
A bunch of operand errors. Might be easy enough to change right now.
Nope. Will need to fix for ipc. Messes with the stack.
I can't figure out how to get make to skip over the code. I'm trying an ifdef, but can't seem to pass it in (using "-D flag")
*** Makefile
What the hell? I'm going to try to make a test program / makefile. This is really annoying.
My example program works just fine. It must be something with my understanding of the Makefile
I needed to edit /components/Makefile.comp
*** cos_asm_upcall.S
Appears to be needed for IPC... maybe returning from a capability.
Will also have to mess with the code to get stacks working (/components/include).
**** cos_asm_upcall_simple_stacks.h
What is #eax supposed to have?
It is shifted left, and then added to %esp (which is loaded with $cos_static_stack).
There is one large stack, which is indexed into by whatever %eax has?
Converting over... we'll see.
**** cos_asm_upcall_simple_stacks.S
Maybe there are too many here.
Wow. Changing that over (not implemented) seemed to allow a lot of other things to be built
*** s_stub.S
Seems to be a generated file in every component (or maybe just those that export an interface).
Will need to find and change the gen-code.
The code is in cos_asm_server_stub.h, which defines a bunch of macros used by the stubs.
Also uses the stack code. This is going to be a pain to change over.
But not now, later. ifdefing out.
*** cos_component.h
Damn it. I was putting this one off.
I don't understand a good deal of what is in here.
Having compilation problems. The -D flag isn't set for any of the components. Slight problem.
Well, that's a bastard of a solution: change the c compiler to "gcc -D X86_64" in the main Makefile.
**** implicite declarations
Okay, I have no idea where cos_mpd_cntl is defined.
There are a few declarations that I can not find.
Maybe they are generated elsewhere? Most start with "cos__"
Right... in cos_component.h. They are all syscalls. How do I get rid of those warnings?
*** dietlibc
It looks like the problem is now that dietlibc has a command not being found... the i386 version. Make issue?
dietlibc is building correctly as x86_64.
Had to edit /components/Makefile.comp; changed the DIETBIN variable.
*** inv.c
This is the beast. Lots of errors.
Why hello pt_regs. So we meet again.
So, still a make problem.
So, pt_regs is defined in a bunch of places. /kernel/include/shared/consts.h for one, which isn't being used here because it is correct.
There is also one in the linux kernel, but I think that it isn't being used, because it is also correct (but I could have my kernel configured wrong? seems unlikely since it runs).
It must be in dietlibc, which doesn't have a similar pt_regs until later versions. I'm going to try to upgrade.
Nope... that didn't fix it. Maybe it is a Make problem after all.
Nope, not a Make problem. I need to figure out which pt_regs is being compiled in.
The problem is only with the non-numbered registers (%r8-%r15 don't have any problems).
That was it: Must be using the linux header, which lists the non-numbered regs without the r (ax for %rax).
**** invalid storage class for function âbrand_execution_completionâ
I don't even know what that error means.
Missing closing brace.
Too tired. Finished for today.
* <2012-09-19 Wed 09:35> Still Merging?
Back at it.
** inv.c
Still a few errors to clean up.
Should I find a more clever way to select registers? Make a name, like reg_arg0 and then just have one define for mapping it to either %ebx or %rdx (or whatever)?
This may work for now, but doesn't once we start using the extra registers that x86_64 provides... maybe. We have extra registers so some code may become simpler. It may not be as simple as a mapping.
Should the spdid be a long? Should the syscalls return long instead of int?
** Undefined symbols
It builds now...
* <2012-09-20 Thu 11:57> I don't know what I'm doing.
I went back to the old Makefiles, and now things don't build. And there are a bunch of warnings.
What are all of these implicite function definitions comming from? It's not a problem x86_32.
** Syscalls
The problem is with all of the unimplemented syscalls. I should make each just a null call I suppose.
I've added them all in. Hopefully they will magically work. Should probably be tested.
** cobj_format.c
Few warnings...
Talked to Gabe, cobj works in a similar manner to elf file format.
Will need to update the load_service to use the correct format (currently something like elf_i386)
** Git
Took a very long time to get everything forked over and then pushed in Git.
Had to shitch from https to ssh, gen some keys, and them to git, and then "ssh-add ~/.ssh/id_rsa"
That last bit seems unimportant, but trust me, it is very important.
** cobj_format.c
Back to this.
Adding vaddr_t to cos_types.h. Already there. Going to actually start using it (starting with cobj_format.c)
Did emacs seriously just start listing the line number as "??". That is helpful.
dietlibc has a few warnings... that I am going to ignore.
** bitmap.h
Seems to only be for 32 bit types. Bitshift warning because WORD_SIZE is now 64 bit.
Used by cslab and cbuf. Do I need to convert these over?
** s_stub.S
Include from src/component/include/cos_asm_server_stub_simple_stack.h is what is actually causeing the problems.
Needs to be converted over. All assembly.
Okay, I need to stop. I can't rewrite the stubs files when I don't even have the syscall reintegrated.
** undefined symbols
When just building the kernel, I'm getting some undefined symbols in cos.ko. Problematic.
Things like cos_syscall_upcall. Let's see if we have actually converted kern_entry and ipc.S
** ipc.S
Should be building now... but something is wrong. Not seeing my code.
Makefiles. The module uses kmake instead of make, so I need to figure out how to define a value.
EXTRA_CFLAGS and EXTRA_AFLAGS
That did the trick (EXTRA_CFLAGS += -D X86_64)
Actually, I had a typo. The problem was that I had a modified version of the makefile. I just reverted to the original.
* <2012-09-21 Fri 10:54> Do I actually need to know what I am doing?
Time to finish the Merge, and get syscalls working again. Then, move on to IPC.
** enter.c / hijack.c
Unfortunately, this was my crap file that I through everything that the module needed into. I need to figure out how to break it up again.
It's a mix of hw_ints.c and hijack.c.
I think that it's done... compile?
Fixed some problems, still a few undefineds.
** page_interposition_fault
I can't find where this label is, even in the regular codebase.
I guess I can declare it in kern_entry.S anyways.
** Testing
I should probably go ahead and snapshot this now.
Well, at least inserting the module didn't blow anything up. Time to test the syscalls.
Segfault!
Reached my test function, right before the syscall code in ipc.S
%rdx looks funny: 00000000ffffffff
Seg is on the null syscall. Which doesn't exist anymore. But that isn't the problem.
Okay, makes the syscall... then blows up.
I was running the wrong test program. The null syscall works. Print does not.
* <2012-09-23 Sun 09:36> IPC?
Debuged a bit last night and didn't get anywhere.
This morning I fixed the problem: I was using the old printk code, which causes problems because it tries to write to the string.
A problem I had fixed days ago, but had forgotten about.
** Clean up code.
* <2012-09-24 Mon 09:48> Okay, IPC
Finished up cleaning the code up from the merge, and also separated out some of my test code.
Need to tackle cos_loader, check on cobj, and that elf file thing.
A few of the component includes are going to need updating, such as bitmap, c_buf, cslab (slab is a data structure, right?), cos_alloc, and many more, I am sure.
** cos_asm_server_stub.h
Included by s_stub.S
cos_asm_stkmgr_stacks.h - I'm going to see if I can just use the simple stacks for now. This code doesn't seem as refined.
I don't understand the Makefile option. I thought I had disabled it, but apparently not.
The labels in cos_asm_stkmgr_stacks.S are confusing. They are not hex: je 2f means jump to 2; forward and jmp 8b means jump to 8; backwards.
Changed to the correct format in cos_loader.c
** c_stub.c
This is the client side stub. I think, at least.
It sets up and makes a IPC call with a syscall (which we have overwritten, and is now handled by kern_entry.S)
I need to see the role that %ecx is playing in the call. In c_stub.c it is set to 0x1f before the call and 0x0 after.
Great, I think I screwed up the call conventions for syscalls. %ebp should be converted to %rbp. That would make more sense than %r9.
Eh. Who cares?
cos_loader is a beast.
Where the hell did this c_stub.c file come from?
** gen_client_stub.c
I guess I should work on this firt. Just get a call into the kernel.
*** asm_ipc_defs.h
Used in gen_client_stub.c. Surely there will need to be some changes.
Where is the thd_invocation_frame struct? Need to get offsets. Of course, thread.h.
All pointers so far, so just doubling.
*** UCAP_SZ
Was the "number of longs" in a struct usr_inv_cap, but is no longer the case (and wasn't actually the case before).
The struct has 2 vaddr_ts and 2 ints. UCAP_SZ isn't actually used, but UCAP_SZ_STR is in gen_client_stub.c:
".rep " UCAP_SZ_STR "\n\t"
.rep is a directive, that appears to mean "repeat the next line n times", so in this case reserving space for the usr_inv_cap. The next line:
".long 0\n\t"
So... change UCAP_SZ_STR to 6? Or should I be using 2 .quads and 2 .longs? Changed to 6 for now.
** compilation
Trying to get link_loader to compile, and realize that I had commented out that little bit (net, translator, and link_load).
Will see if I can add them back in one at a time.
*** net
A bunch of undefineds in the cnet.ko, such as "cos_net_prebrand".
I can't figure out the problem. cos_net_prebrand is defined in kernel/inv.c, and used in hijack.c
Okay, I'm just going to move on for now.
*** translator
Three undefineds, such as cos_trans_dereg
Very similar to the net problems. Declared and used elsewhere... Odd. Moving on. I really don't feel like figuring out compilation issues.
*** link_load
Ran just fine. That's odd.
** cos_asm_server_stub_simple_stack.h
* <2012-09-25 Tue 09:33> IPC into the kernel
I'm working on just getting a component to call into the kernel.
The problem is that I don't know how to get a minimal system running. Large chunks do not compile.
I don't seem to have the initial component, c0, building.
But I shouldn't need that. I should be able to just build a component when makes and IPC call and dies.
** comp0
Need to get this component built and running. Hmm... it already is being built.
There really isn't anything too it.
** Test component
Even more simple that ping (which prints!).
The sched dependency may be too much, as that is throwing warnings since it "doesn't exist"
I don't know why it doesn't. As far as I can tell it exists and is building happily.
Alright... let's get this done.
** Interfaces
Even comp0 has dependencies on non-existent interfaces. Namely sched_hier and stkmgr.
Why aren't any of these interfaces found? I'm not seeing them in the transfer directory, maybe they aren't being built?
There seems to be an inconsistency with the assembly conventions for ipc as described in ipc.S vs that used in cos_asm_server_stub_simple_stack.h
Perhaps it is only between the code and the comments. A much more likely scenario.
Alright, the interfaces all build. I had to go ahead and fix cos_asm_server_stub_simple_stack.h. It's probably wrong, but I wanted them to build.
** Run james_test
Need to write a run script first.
./cos_loader "c0.o, :c0.o;" ./gen_client_stub
I'm just trying to get the most basic system working. But everything has a bunch of dependencies. c0.o needs fprr.o which needs a few more.
At least the line above gives a non-dependency related error: cos_loader: cos_loader.c:1442: get_service_struct: Assertion `name' failed.
Maybe I can deal with the Assert.
get_service_struct is being passed a null name. It is called by deserialize_dependencies, so probably actually a dependency problem.
** Run c0.o
I tried to load in the bare minimum, but apparently schedconf.o is needed, and I don't have that building.
There must be a simpler scheduler that I can use.
Maybe, ds.o and llboot.o.
ds.o also depends on schedconf.o, but llboot.o doesn't seem to! At least not in unit_torrent.sh.
With just trying to load c0.o and llboot.o, I get the assert at 1442 error. 
* <2012-09-27 Thu 10:43> IPC
** assert 1442 error
This probably shouldn't be failing.
Time to printf the fuck out of cos_loader!
There is already a bunch of print commands, just setting the level to PRINT_DEBUG.
Hmm... there are a bunch of warnings compiling cos_loader, maybe I should fix them first.
The errors are in all of the PRINT_DEBUG level print commands, but the problem is much deeper. 
Many of the variables used for addresses are typed as ints. This probably isn't going to work.
** Pointers and the ints that represent them.
I'm not sure how to deal with all of these variables. ro_start is an unsigned long, so it should be fine.
Variables like ro_size are unsigned ints, which also seems reasonable.
Some of the cobj_format function calls seem to return undesireable types.
** cobj_format.h
Do I need to convert these addresses over? Should they all be vaddr_t?
Or paddr_t? How do I tell the difference between phsyical and virtual addresses?
"never meant to be dereferenced" but this is how I am finding them in the first place! Shit.
How about a pointer data type? no... that should be typed anyways.
Or a generic address? Then I could figure out later what it should be.
Long long are always 64 bits. Makes sense. So I should use the new gaddr_t even for derefferenced address, despite the comment, if only so that I have an easy way to find the changes at a later point.
*** questions
In cobj_format.h, some of the defined cos_types are used.
void * cobj_vaddr_get(...) - why doesn't this return a vaddr_t?
u32_t cobj_sect_addr(...) - why is the section address a int? Is it relative to the start address of the object?
** Compiling?
I changed something, and now those warnings have all gone away. Or are just burried. Let's try running it!
How the hell is "File Exists" an error?
Progress; a different error: "Object open failure: Invalid bfd target" Clean and build? Find all i386 refs?
Gah! Where was I changing those formats? I thought I found another file referencing elf32-i386. I must have been in the wrong source again.
The warnings have re-appeared!
** Warnings of a certain Type.
I fixed most of them, but don't know how to touch cos_loader.c:2529. It is dealing with pointers and the heap.
** I'm doing everything wrong. Also, cos_component is not compiling.
cos_component is going to compile as cos_mandatory.o, which happens to be kinda of essential.
As far as I can tell, cos_component is compiling just find.
c0.o, however, seems to have all of its symbols defined at 0. Except the undefined ones, like main.
Error: component no_interface.comp0 does not have stated dependencies to provide ['main']
Hmm... no_interface/comp0 seems to depend upon sched_hier
** sched_hier
And Sched has a bunch of dependencies. I think that I am going to have to get them all compiling.
Depends on printc
** printc
Depends on... nothing. But:
does not have stated dependencies to provide ['cos_static_stack']
This is a fairly common problem. Do I have to implement the stack stuff?
I don't see what is causing these problems. There are no errors with any stack stuff that I can find.
** c_stub.c
This is an act of desparation. I'm going to fix the first errors that I find.
This seems like a better idea than trying to convert the stack manager code over.
Maybe the problem is with how I commented out the stack manager.
** c_stub.h
Maybe this is it. I'll just convert it over to x86_64.
This code shouldn't actually be needed until I try to do the return path for IPC.
Gah, back to this assembly directive problem for inline.
I'm following the conventions, so maybe I don't need to worry about specifying the exact registers?
Alright... still problems. - assembly typo.
I was going to try to convert the pong c_stub.c file over to use c_stub.h, but I'm lost. Too many defines.
I was delcaring a output register as a clobbered one, which resulted in: can't find a register in class âCREGâ while reloading âasmâ
** Dependencies
I still have the dependencies problem, so it had nothing to do with what I just got compiling. Which isn't too surprising.
Alright, the cos_static_stack dependency problem is from disabling the stack manager. I don't want to fix that until I have to.
I don't see where the missing "main" is coming from though.
I might have to take care of the stack thing soon, looks like it is included in comp0's Makefile.
** Stated Dependencies
Maybe a search for the code printing out the message would help.
It is printed out by: /src/components/cidl/verify_completeness.py 
This doesn't help me too much, because this is not the code that is assembling the component. It must be cobj, right?
The problem may be that some addresses are being typed as u32_t, instead of vaddr_t. Messing with the types in cobj_format.h.
What is cobj_sect:bytes? Changing cobj_sect:vaddr to a vaddr_t (just seems right).
cobj_cap_init:cstub and sstub, are these addresses?
** compilation errors
Finally, some compilation errors to fix! cobj_format.c related.
Fixed those... but still having the composite linking troubles.
Also, an object dump of c0.o shows a lot of 0 addresses.
Damn, I think sect is an offset. But that shouldn't actually be screwing things up. False alarm. It's not.
** Two mains
Alright... now I'm getting an error that main has already been defined.
The cause is that the testing code in cobj_format has a main function so that it can be tested as a standalone program. It's just a bit funny since my current problem is not enough mains. Sigh.
I don't know where my printf is actually being executed. This is a pain. Errors in cos_loader. Should check there for the cobj_format stuff.
** heap_ptr
Can die in a fire. I am, of course, assuming that the heap is now 64 bit addressable. If not, then I am going to have to undo all of the un-niceness.
Well, in cos_types.h:cos_component_info:cos_heap_ptr it is a vaddr_t, so hopefully it is correct. Of course, I could have been the one to do that...
Good news, Gabe set it as a vaddr_t, so I am probably on the right track.
** Still no main (dependency problems continue)
The problem is not with cos_loader (where I was working on the heap_ptr stuff), since cos_loader is one of the last things to be built.
So... ?
Maybe I should look into those mysterious python scripts.
** exp_ifs.py
Oh God, what fresh hell is this?
These scripts are parsing the Makefiles, and figuring out the dependency structure.
** mmap
I'm going to need to understand this linux system call.
* <2012-09-28 Fri 10:22> Linking, IPC
I am having trouble getting things to link correctly on the composite side of things.
The problem seems to be with all components, so it is not specific to my new component.
Things are linking fine with c, but cidl/verify_completeness.py is throwing errors.
The problem is not with cos_loader, since that isn't run until later.
I'm not sure if cobj_format could be the culprit. It may be that the format is wrong, preventing the python scripts from finding the functions.
** If I knew what I was doing, I could write a better title.
It is odd, that some components compile just fine and others are having difficulty.
Talked to Gabe. The problem is with the c linking. The python scipts are just there for error checking, which their name implies. Also, I think it is safe to say that they worked.
The course of action is to now try linking manually. Then seeing how that process differs from the automated system.
Finally, we should invent a build system which is not absolutely horrible (hint: this is impossible).
** Manual Linking
Gabe stopped by, and figured out the problem (but not the solution).
Main is called by dietlibc, but dietlibc is the last thing to be linked in. Since main is declared in a statically linked library (liscos_component.a) but not called when that library is linked, it is not linked in. Then dietlibc tries to call it and fails.
The solution? Gabe will get back to me... hopefully. I'll look around too I suppose.
* <2012-10-01 Mon 13:25> Linking? Or running?
The temporary fix for the linking problem is just to make sure that there is a reference to main. That way it isn't stripped out when linked statically.
** Linking kludge.
Focus. Ignore the sea of code. Dive in. Drown.
Let's compile, and then see what other components are erroring out. Comp0 should be fine.
I think it actually compiled fine. And linked. This is odd. There are other components that aren't linking yet, but I don't need them yet.
** Module aed not inserted.  Please load.
It ran! And gave the above error. Lots of things were printed out, and they looked correct-ish.
It is correct, I have no aed module. To bad I don't know what that is. But I have seen code for it lying around here somewhere.
** AED
Asymmetric Execution Domain. It is something that I had commented out in hijack.c.
I really hope that all of the "handle" variables in the structs in aed_ioctl.h are okay as ints.
The code seems to be responsible for taking care of ioctl() requests. These are commands for special files in linux, such as one that represent the terminal. And given that the aed module has functions about scheduling and memory, ioctl must be involved with that as well.
It should be platform independent.
Hmm... undefined symbol in cos.ko: 
** check_offsets
This is called in hijack.c:aed_open, which is why it is now a problem that it is undefined in cos.ko.
This is the runtime check to make sure that I updated the offsets in kernel/include/ correctly. the files all seem to exists... so it must be a build issue.
Of course. The header is being included, but I don't think that the c file is actually being compiled. Do I move the c file? Add it all to the header?
Oh right, can add it to the makefile.
** Could not get pgd_offset in the kernel map. 
Module aed not inserted. Please load. <- still printed out, but the problem is elsewhere now.
The problem is with pgd_offset, or maybe it's arguments. It is provided by linux. It returns the offset into the page global directory for an address.
I think we should switch the call to pgd_offset_k... assuming that we are interested in the linux kernel and not the composite kernel.
Hmm... init_mm is now no longer defined in cos.ko. Ah, it is used in the shortcut pgd_offset_k. So, back to pgd_offset.
init_mm is declared as an extern in linux/sched.h, which is already included in hijack.c. It is defined in a .c file. So my guess is that pgd_offset_k is not intended to be used outside of the kernel. Which, now that I think about it, makes absolutely perfect sense.
** The plot thickens.
Seems like kern_mm is being set correctly. I must be something else.
pgd is ending up null. Maybe the COS_INFO_REGION_ADDR is set incorrectly? It is defined in consts.h
Hmm... The place to look may be pgd_offset. It expands to: ((kern_mm)->pgd + pgd_index((COS_INFO_REGION_ADDR)))
Well, the pgd for kern_mm is apparently null. That would explain it, I suppose.
So how do I fix that?
** aed_allocate_mm
This must be failing. printk time.
Alright. More confused than before. alloc_mm is being called. And it works, at least for the first call to it: mm->pgd is not null.
On the second call though, it fails. And mm ends up having the same address as the first one. This seems wrong.
Finally. The aed_allocate_mm function is finishing all the way, but the error code seems to be 0. 
Wrong.
Okay, so there is just one call to aed_allocate_mm. And it seems to work just dandy.
So, the next call, aed_get_mm must be botching the job somehow.
** aed_get_mm
But this function is just getting a reference from an array!?!
GAH! I was dereferencing a pointer in my print statement!
So I just super confirmed that aed_allocate_mm and aed_get_mm work as expected.
** pgd_offset
So. Back to where we started. Something is going wrong with this function. So the COS_INFO_REGION_ADDR must be wrong.
* <2012-10-02 Tue 13:12> Page Offset
I don't know what the problem is, so I'm going to read up on it for a bit.
** 64 bit range
Never have been so happy to crash my VM.
Changed #define SHARED_REGION_START from 1<<30 to 0xffff880040000000
I don't yet have a good theory as to why using the lower address (which should still be a legal address since the can use the lowest 2^47 address and the highest 2^47 address) doesn't work.
I'm going to try to have it exit gracefully, and see what gets printed out.
Maybe it has something do with that being where the kern_mm is already mapped. Maybe linux uses the upper address for native 64 applications.
** Actually
Something is still wrong. 
And now it really doesn't make sense.
** Stepping through.
mm_struct <- represents the address space for a process. 
There are a few different memory map structures that composite is juggleing:
> kern_mm - The is likely just for the composite kernel
> current - The currently running component?
> composite_union_mm - Perhaps the mappings for everything that composite is using.
This would suggest the the problems are not with the offset into the pgd, but if that data was mapped in in the first place.
* <2012-10-04 Thu 10:53> Into the abyss
Is that how you spell abyss?
Spent yesterday on other work and the Fishing School. And setting up this computer.
Which means I'll now have two versions of this VM. That could get confusing. The code is all in git though.
So the question this morning is: Do I work on the Page problem or just skip it for now?
** Disabling the paging system
Let's skip it for now.
And..... Seg Fault.
Something in chk_offsets.c. Better to error here than elsewhere.
Great... killed something. I can't remove the cos module. Need to reboot.
** I'm back! Snapshot time.
At least it is something I actually know how to fix. The defined offsets are incorrect.
Haven't I changed these all before?
** gen_client_stub.c UCAP_SZ_STR
That god-damn:
  .rep UCAP_SZ_STR
  .long 0
It's going to have to arch specific... since we need quads not long.... unless
Just need to reserve 24 bytes. Doesn't matter if it is done as 6 longs or 3 quads (hopefully!).
I think that I resolved that in a fashion that won't give too many other programmers splitting head-aches.
Sigh. Need to restart.
** Seg Fault!
Of a different sort. So... yeah, progress. Especially since I could remove cos.ko after the crash.
cos_loader[9290]: segfault at 0 ip (null) sp 00007fffe64bebd8 error 14 $n cos_loader[400000+d000]
So... ip is null. That seems bad. cos_loader[400000+d000] seems usefull. 1 gig is where the memory is supposed to start, not sure what happens at 1 gig + 52kb.
Time to push so that I can use my laptop.
** Debugging seg fault
The function aed_open seems to exit just fine. I'll leave the checks for when I try to uncomment the kernel page part.
Talked to Gabe. Debugged with him. Didn't learn anythings. Trying again.
The code segfaults with the first system call after aed_open.
Even dies if the aed_open call immediately returns.
So. The system call path must be messed up when a call from... nevermind.
The program is being killed because of the "return 1;" instead of 0.
** spd.c:322?
Now this is where the problem lands.
This is a problem for later. First, the current problem.
** aed_open
Have to restart again.
Did a binary search for the line causing the error, and found it! (Because of the return 0s).
AND I did a sanity check on it, and I am in fact sane. Really.
What line was it? Well, now that I know, it all seems so obvious:
** ipc_init()
./kernel/include/ipc.h:ipc_init

* <2012-10-05 Fri 15:44> What is dying in cos_loader?
** ipc_init
Actually, ./kernel/inv.c:ipc_init
  memset(shared_data_page, 0, PAGE_SIZE); 
  rdtscl(cycle_cnt);
That is all that the function does. I should probably check that page size is correct.
PAGE_SIZE is defined in consts.h, and is (1 << PAGE_ORDER), which is the same in the linux kernel (PAGE_ORDER is 12).
I'm going to test out the getpagesize function provided by unistd.h.
As expected, PAGE_SIZE is the same on both platforms (4096 bytes).
So, shared_data_page or rdtscl as the next culprit?
** rdtscl(cycle_cnt)
That's it! Probably.
It is a define, which ends up expanding out to some assembly. I bet it is clobbering something.
What happens if I just comment out the line? It works! Wait... I've been here before. Sanity check time.
We've crashed.
* <2012-10-08 Mon 11:27> Finish IPC
** rdtscl(cycle_cnt)
Why are there 3 defined (okay, one is rdtscll)?
The command, rdstc, stands for read time-stamp counter, or how many cycles have passed since the last cpu reset.
The 64 bit behavior seems to be very similar to 32 bit, which returns the 64 bit register as EDX:EAX. 64 bit does the same, and clears the highorder bits from RDX and RAX
/* We cannot use "=A", since this would use %rax on x86_64 */ <- linux source
That would seem to imply that we can not use "=A"
This complicates things. I'm going to try writing a test program to make sure I can acutally replace the existing code.
I'm fairly certain that I am the man. I think I have the code working.
Hmm... rdtscll works as would be expected: getting the 64 bit value.
rdtscl only returns the lower 32 bits.
I'm switching the calls to rdtscll.
** Still having troubles
I'm not sure if it is just something that is breaking later.
Alright, I'm going to forge ahead anyways. Now I am getting a seg fault.
At the same point that was giving me a problem before (as far as I can tell).
Is it time for sanity checks? I hate it when my sanity checks fail.
Crash.
** cos_init_memory()
This seems to be having a bit of an issue
This wouldn't take so long if I didn't have to restart every time I wanted to test something.
I am begining to suspect va_to_pa, since that function also exists in the code I had to comment out aed_open().
** va_to_pa
It's just a hunch.
Hmm... __pa(va) <- that seems reasonable.
It's called a few times, but I can't find where it is defined.
It's a linux function. The function va_to_pa and pa_to_va seems to exist just to cast to a "void *", which should be fine since linux has it return an unsigned long.
It is possible that I can not call cos_init_memory since I commented out that previous bit that also deals with memory.
** kern_mm
Why isn't this working? Do I really want to try to fix it now?
Where is the pmd? Not a problem earlier.
How many levels do I have? 2? 3? 4? And how do I check this?
Hopefully I can just use the value defined in the linux kernel.
4. We have 4 levels. PAE only uses 3, so I'm guessing that if composite couldn't handle PAE then it definately can't handle 4 levels.
** 4 level Page Tables.
I probably need to change the values of things like PGD_SHIFT
I'm a bit confused.
Hmm... I have broken everything. But at least now I know what depends on consts.h page table stuff.
So, cand I just lock the first few levels? Everyon component has the same PUD and PMD and PGD?
And killed something.
** Moving on.
I can't make heads or tails of the page table stuff.
** Could not create spd

* <2012-10-09 Tue 10:07> Actually finish IPC?
Should I start by ripping out SPDs and Memory? Or fixing them?
GAH!
I'm not making any progress.
And crash.
Okay. Time to get this done.
Crash.
** kern_mm = current->mm;
I'm not sure yet if this was a good idea of a horrible one.
Hmm.... I will need to change it back later. May have revealed two problems (or one... I'm so confused).
** pte_t *pte = lookup_address_mm(current->mm, COS_INFO_REGION_ADDR);
This line appears to not be setting *pte to a correct value, since we fail out if we print it.
This may explain the problems later on with reaching COS_INFO_REGION_ADDR after kern_mm is set to = current->mm.
Crash.
For some reason there is no pmd for COS_INFO_REGION_ADDR. I'm stumped. Going home. Emailed Gabe.

* <2012-10-10 Wed 13:45> Memory problem
Gabe replied to my email, and pointed out two functions that I had somehow managed to completely miss.
** hijack.c:pgtbl_add_middledir
There are actually a bunch of helper functions like this. I don't know how I missed out on them earlier.
Used in pgtble_add_middledir_range, which is used in spd.c, So, will probably have to fix this.
Okay, maybe pmd is supposed to be a 0 at that point. I can't seem to find any init code before it.
** shared_region_pte[0].pte_low = (unsigned long)(data_page) | (_PAGE_PRESENT | _PAGE_RW | _PAGE_USER | _PAGE_ACCESSED);
* <2012-10-11 Thu 12:12> Today will be the day
I'll come back to pgtbl_add_middledir. At the very least, it isn't being called before my problems begin.
So, let's assume that lookup_address_mm(current->mm, COS_INFO_REGION_ADDR); doesn't fill in pmd.
Which makes sense, right? COS_INFO_REGION_ADDR is 40000000, which means in a 4 level system... The offset would be 0, the table entry 0, and the middle level 0.
Am I confusing physical vs virtual adresses? Physical addresses are much shorter than the virtual... at least when the virtual are in the upper partition (0xffff....)
** shared_region_pte
Crash. I have no idea what is going wrong.
** shared_data_page
This is an array, which should represent one single single page, thus the size of 512 in 64 and 1024 in 32 bit (word size goes from 8 to 4, is 4Kbs (2^12))
It is declared in kernel/inv.c, and used in hijack.c
The variable data page is the physical address of the entry which should have that page (may be missing a bit, but at least has the pmd and pte)
** shared_region_pte[0].pte
This is no good because it is only saving the pte, neglecting (at least) the pmd. This used to be okay, since in the 2 level page tables, the pgd was know. (now I am hoping that the pgd and perhaps the pud is known).

** pgtbl_vaddr_to_kaddr
As far as I can tell, this function is working perfectly.

* <2012-10-12 Fri 11:11> Alright.
Something is going wrong... somewhere. 
I've re-read everything about page tables, so I think I understand what is going on with them.
** kern_mm
I need to figure out why composite is failing at access the shared data page here.
I'm not seeing it.
** pte_t *pte = lookup_address_mm(current->mm, COS_INFO_REGION_ADDR); 
Why is this line (first in hijack.c:aed_open) failing? PGD seems good, PUD is good, and then the PMD is bad.
Are we failing to map it in properly earlier? Or is it okay....
"Map it in" doesn't really make sense, does it? Allocated? Why am I so confused?
After this line, pte = 0.... so why doesn't the error check on it trip up?
Okay, the check is: if (pte != NULL) then error.
pte isn't supposed to be anything yet. If it was already in the page table, then the memory has already been allocated.
** struct_mm
These structures keep track of the page table for a process (and orther memory bits).
Hijack.c is manipulating three:
*** current->mm
This is the current thread's struct_mm
*** kern_mm
This is only supposed to have mappings for the composite kernel.
Something is going wrong with it's allocation or the mapping of COS_INFO_REGION_ADDR into it.
*** composite_union_mm
I'm not sure exactly
My assumption is that this will have the page table for everything in composite, including the kern_mm
** data_page
So, where to we hook in COS_INFO_REGION_ADDR?
shared_region_pte is set to the pte for shared_region_page. This seems correct.
Next, memset 0's out the page. PAGE_SIZE is set correctly. yup. 1 << 12 = 4kB.
data_page is set to the physical address of shared_data_page. Seems correct.
shared_region_pte[0].pte is set to data_page. Now data_page and shared_region_pte are the same, and related to shared_data_page as well.
All seems good. I don't see the problem that Gabe was getting at.
** Placing in pgd.... hm, maybe this is the source of our troubles.
pgd->pgd = (unsigned long)(__pa(shared_region_pte)) | _PAGE_TABLE;
I can't believe I didn't see this earlier.
Obviously, setting the pgd to a pte is cutting out the pud and pmd. Duh.
Crashed.
** And we are back.
So, clearly, I need to start filling in the page tables so that COS_INFO_REGION_ADDR is actually there.
Alright, I'm making progress. But I'm not setting each level to the correct value.
I'm setting everything to be the final pte value, which, surprise surprise, is a rather poor choice.
Killed.

* <2012-10-14 Sun 11:11> Page Tables
First I need to finish pulling from git.
** Shared data pte
I'm trying to map in the pte for shared data, but I keep killing the kernel. Restart again.
Not sure what is going wrong.
When I walk the page tables looking for COS_INFO_REGION_ADDR, pmd_offset fails.
I guess this makes sense... I have to map it in.
** Allocate pages
Gabe emailed me back, and made some things more clear.
When pmd_offset fails (or pud_offset for that matter), I need to allocate a page.
And example of this should be in the spd creation code, since spd's need to allocate some shared data.
** spd.c:spd_alloc_pgtbl
I've looked at this code before.
Okay, after a complicated loop (inv.c:cos_syscall_spd_cntl -> spd.c:spd_alloc_pgtbl -> page_pool.c:cos_get_pg_pool -> hijack.c:cos_alloc_page) we are back into hijack.
hijack.c:cos_alloc_page() - not the most exciting function, just calls __get_free_pages and then memsets them 0.
But the page has been allocated. I just need to correct its pmd.
** pmd

* <2012-10-15 Mon 11:03> Page Tables
Shared region needs to be mapped into cos_kernel.
The course seems clear: I need to attemp to walk the tables to the location it should be. If pages are missing, then allocate them and fill in correct indexes.
And by clear, I mean only at a very high level.
** Allocate a page
Do I need to keep a list of pages used to free later?
Can I switch to get_zeroed_page instead of __get_free_pages in cos_alloc_page since the order is 0 and he memsets anyways?
The only reason not to, that I can see, is that if the call fails it would be nice to know on which step.
GFP_KERNEL: Flag defined by linux, means that it is okay for the kernel to sleep during allocation (basically, that we are not in an interrupt handler). Okay for me to use here.
** page_pool
I started looking here to see if I should use it to manage any pages allocated in hijack for page tables, but now I am confused.
page_pool.h:struct page_list is defined as only having one element: struct page_list *next
I don't see how this is useful, since it just points to another page_list... a linked list with links but no data.
After reading through the code and how spd.c uses, I am still confused as to what is happening.
When a page is allocated from the page_pool, its next value is set to null (page_pool pulls from its next value, which is then replaced by the next of the returned page).
So, the address of the page_list struct must correspond to an actual page address.
Yup, that looks like what it is doing. Too bad hijack doesn't include this file... I guess I should keep track of pages myself.
** Allocate a page
Too many details. Just allocate a page and see if you can use it in the page table structure. Worry about freeing it later.
Alright, I'm able to (I think) correctly allocate a page as needed for the pmd level, and then set the pte to point to the shared memory.
Of course, this is wrong. Gabe is using one level up, so that the page is 4MB instead of 4KB, but in 4 (and 3) level tables, the larger page is actually only 2MB. The 2 level table uses 10 / 10 bits, 3 (PAE) uses 2 / 9 / 9, and 4 uses 9 / 9 / 9 at least for now.
** 2MB pages
I'm tired of crashing. Alright. Seems like what I have could be correct. I am dubious though.
Well... seg-fault, but let's see if I got the shared region setup correctly.
cos: Mapping of shared region worked: deadbeef. 
Huzzah! Looks like it worked!
And complete freeze. Not surpising since we are getting much further along in the boot process now.
** *pte: 80000000209c6067
This seems problemmatic.
There are a lot of functions in hijack that mess with page tables, and need to be fixed.
*** copy_pgd_range
** What is the job of translator?

* <2012-10-16 Tue 09:15> Page Table Functions
According to my excellent grep skills, (grep "void [a-z|A-Z]*_pgtbl" hijack.c), I have 8 functions to fix.
The tricky part will be how to test them.
Well, 11 with grep "void [a-z|A-Z]*_*[a-z|A-Z]*_pgtbl" hijack.c (includes "void print_valid_pgtbl)
Of course, there could be some non-void ones: unsigned long get_valid_pgtbl_entry(paddr_t pt, int n)
This is a lot of code to change. I think that I am going to extract all of the page table code.
Okay, I should leave grep to the experts. There are a bunch of functions.
** page_tables.h
I'm pulling all of the page table related functions out.
Eventually this will have to become part of the Hardware Abstraction Layer, but for now I'm just throwing it here.
Gabe hates the #ifdefs, but I hate build systems about as much.
This is taking a long time. Turns out that page tables are a huge part of the hijack code, which makes sense, I suppose.
I will need to change the function names to differentiate between big and regular pages (since pgd no longer makes sense.
* <2012-10-18 Thu 11:01> Page Tables
I need to finish page tables so that I can move ahead with IPC.
And I just crashed the VM. Perhaps I have made an error with my edits.
How did I screw this up? Surprisingly, a make clean fixed it.
** cos: could not translate the user-cap address, 40606000, into a kernel vaddr for spd 1
So, back to where I was before, but now page table code has been ripped out of hijack. Git commit?
Sigh.
** Fixing page tables code
I don't think that I need to keep track of pages allocated to fill in the page table.
These should be cleaned up as the page tables are deallocated; should be able to walk the tables freeing everything.
** pte: ffff880027cbf030  *pte: 8000000025015067
This seems familiar.
I wonder if this is okay. I mean, what's an extra bit among friends?
Gah! This is shit.
** Page issues
pmd_large is a linux function that checks if a page has the page_pse (Page Size Extension) flag: it is more that 4kb.
This lets you tell when a page is a regular one or a 2MB one (used to be 4MB, thus a lot of the issues).
That didn't seem to fix my problem. Maybe I am not setting the page_pse flag correctly.
** pgtbl_add_middledir
This function should add in a new page if one isn't mapped in.
This should be replaced by a function that 
** HPAGE_SIZE
I'm starting to think that this should be 2MB.
It's set by HPAGE_SHIFT, which in 2-levels is 22 (after a convoluted path), and in 3 and 4 levels it's 21.
These correspond of course to 4MB and 2MB.
But, with the ifdef where it is defined, it's possible that it is already set correctly, since we are including so much from linux. It still (obviously) needs to be changed, it just is unlikely that it is causing my current problems.
** pgtbl_fill_to_dir
I added this function since I kept having to write the same code over and over.
Will probably need a similar remove pages function, but this is going to be complicated.
For example, will need to make sure that none of the other entries are mapped before deallocating.

* <2012-10-22 Mon 11:24> Page Tables
I NEED to finish with page tables and start making progress with IPC.
Still working on the functions that I striped out into page_tables.c
** copy_pgtbl_range and related
These are the tough ones. It seems like I can assume that everything should be working on pmds instead of pgds.
** copy_pgtbl_range_nocheck(pt_to, pt_from, 0, 0xFFFFFFFF); 
This is in copy_pgtbl.
Seems intended to copy the entire address space. Should give hints as to how the rest of the functions work.
** hpage_index(size)
This function is going to return the number of pages needed for the size of memory.
This sucks.
Soo... everything is assuming big pages, right?
Okay. So I need to find the starting pmd, copy everything in it, then move on to the next pmd?
I don't know how to do this.
The range of tables specified may not even be mapped in for everything..... gah!
** pud
Alright, I am just going to assume that everything is within one pmd.
This limits memory to 1024MB if I'm not mistaken, but is much easier to code.
Also, we are only dealing with big pages, as far as I can tell.

* <2012-10-24 Wed 11:26> Still Page Tables
Time to refocus, and get this done.
Four steps: 
** Stop seg-faulting
Constantly restarting is killing my productivity. 
I should be able to set up memory and all and then bail before seg-faulting.
Startup is a bit confusing though... should look into cos_loader. It's a beast.
Might be failing in cos_loader.c:setup_kernel, should run in gdb, see what happens.
*** #define rdtscll(val)
What is this doing in cos_loader? Didn't I have problems with this before?
I thought that I had fixed this, but I guess not? I had test code for it and everything.
I did, but only in the header files. What a giant pain. rdtscl related defines are in 3 headers and 6 c files.
Should I just copy and paste into each one of them? This is one of those "I just want to go home" moments.
Looks like I likely had the rdtscl defines wrong. Looking at t.c in dietlibc, for just getting the low bits the original code is fine (it uses "a" and "edx", it is "A" that is problematic).
Hopefully that was all of them.
*** Seg-faulting?
Still seg-faulting, the problem is likely occuring before the rdtscll calls, but at least that is probably fixed.
Happens while printing addresses for components: 
Found cos_atomic_user4_end address for component /tmp/c0.o.26382.o @ 40400051. 
Restart.
*** Setting up Sevices
Sets up first service just fine, fails setting up the second service... which is...
First is c0, second should be llboot.
It's failing setting something up, probably a null pointer.
Services are passed into setup_kernel, so could be from an earlier problem.
Restart.
*** aed_ioctl.h:cos_create_spd
By the power of printfs, I have found that the problem is here. Which is surprising; it's a simple function.
ioctl is an interface provided by linux to interact with hardware (input output control).
We are adding new functions, which are implemented in hijack.c.
*** hijack.c:aed_ioctl case AED_CREATE_SPD
This is the likely culprit.
And this function copies page tables. I guess I found the problem.
I'm going home.
** Test current page table code
** Fix pgtbl_copy and related functions
** Start IPC.
* <2012-10-25 Thu 10:33> Finish Page Tables
I did not get that far yesterday.
But I found where the crash is happening: copying page tables for the second component.
So, here are the three tasks that I didn't get to yesterday:
** Test current page table code
I'm not sure what would be the easiest way to test this. Maybe I should try outside of the composite code base.
And then again, maybe not.
Alright. I've tested it (copied into JAWS). I tested the copy_pgtbl function, which in turn uses others.
Granted, not the most thorough (hpage_index might be wrong, but unlikely), but I now doubt it is the source of my problems.
Gabe explained the copy functions, and they actually are simple. It's okay if they only operate on the top level.
** Fix pgtbl_copy and related functions
As far as I can tell, these are likely fine. See above.
** Start IPC
Well, there still seems to be a seg fault in here, so I guess I need to fix that first.
** Seg-Fault
I have the source: spd.c:pages_identical
Fed into the function is vaddr_cap: 0000000040606000, cap: 7fff880025b6f000    
Which look fairly un-identical. But these are page addresses. The function checks if the addresses map to the same page.
The second address is the one throwing the seg-fault. Seems fine.... why is the leading bit 0?
** pgtbl_vaddr_to_kaddr
This function, as far as I can tell, is absolutely fine. It gives valid addresses for the preceding calls.
It has got to be that leading 0. I'm pretty sure that that makes it non-canonical.
* <2012-10-26 Fri 10:30> Mystery Error
So, the page table code (copy functions at least) were correct all along. So now I need to figure out where
this non-canonical address is comming from. Back to that funny *pte? the 800...0029xxxx one?
** The leading bit
Avoid the seg fault, and track down where this bit is being set.
It's getting messed up in the lookup? Maybe we are using pte_offset_kernel incorrectly.
Ternary statements!
And restart.

* <2012-10-31 Wed 10:49> Page Tables
I thought I was done.
The problem seems to be in the copy functions that are called when creating new spds/mpds. The others should be fine.
** copy_pgd_range
Problem must be in setting the pte before we get to spd.c:spd_set_location.
* <2012-11-01 Thu 13:37> Memory problem
I don't know what is causing the problem. Sigh.
** thread.c
What am I doing here? Uses COS_INFO_ADDR_REGION, seemingly incorrectly now. Maybe.
Isn't being used yet, changed code to fail out before the bits that need to be fixed.
** spd.c
* <2012-11-02 Fri 10:56> Address 0x40606000
Why is it already populated?

* <2012-11-05 Mon 11:40> Moving on
The demon bit is to make an address as non-executable. Addresses used by spds, such as the problematic 0x40606000, are mapped in with mmap (or a variant thereof) which sets the bit as a protection mechanism.
I should have gone to the documentation for IA32e (yes, that is actually what Intel calls memory management for x86_64) much earlier. My guess of an unsigned vs signed or long vs int problem was ultimately unfounded, although I suspect I took care of a few future errors in the process of inspecting the code. My guess that the bit was some sort of flag ended up being true, but I was looking in the wrong places. I focused on the Linux implementation which sets low order bits as flags, instead of the actual culprit: Intel.
The question remains if pte_val in Linux should mask out the bit. But no matter.
** Masking out the bit.
A simple change to page_tables.c.
And cleaning up all of the debug code and bits I commented out.
Apparently it is not that simple. And I am having trouble with bitwise operations...
Okay, literals are by default ints, not unsigned ints. I need to get to the point where I can read the warnings again.
** Cleaning up
I need to find where I had the code failing out before.
** THE FOLLOW CODE NEEDS TO BE FIXED! FAILING OUT! 
thread.c:thd_alloc is the offending function.

* <2012-11-06 Tue 11:52> Cleaning up
Still cleaning up the code. Then it's time to tackle the next bug.
There is a lot of code that needs to be cleaned up.
I think that I am going to try get to a running system first. Then I will at least know if I blow something up.
** kernel/spd.c
** kernel/inv.c
** hijack.c
** cpy_pgd_range
** copy_pgtbl_range_nocheck
** int (*fn)(void);
In cos_loader.c:setup_kernel
fn = (int (*)(void))get_symb_address(&s->exported, "spd0_main");
So it is a function pointer... where in c0 is it defined?
That line seems correct. It calls spd0_main and gets the correct return value. Success!
* <2012-11-08 Thu 13:04> Lost
So, not sure if I should actually clean things up, or just push ahead. Should probably fix that page table thing.
** Page Tables
Okay. Fuck.
*** consts.h
In trying to fix hpage_index, I ended up back up consts.h, which has a few constants that assume a two level page table structure (Looking at you, PGDIR_SHIFT 21). I had tried to fix it before, but gave up. Now I remember why.
Actually, I'm getting a ton of warnings and errors... maybe I should take care of them first.
** Warnings / Errors
Long neglected. Here I go!
*** /components//include/cbuf.h:
258: warning: cast to pointer from integer of different size
ret = ((void*)(cm->nfo.c.ptr << PAGE_ORDER));
cm is a struct cbuf_meta*
Hmm... Gabe said to ignore components for now. So yeah, not going to actually mess with it.
*** spd.c
Can't ignore this one.
* <2012-11-09 Fri 12:30> Sprint
First get a build going. Then fix page tables. Then test. Then clean up more code. Then move ahead.
** spd.c
spd_add_location... SERVICE_SIZE... in consts.h of course
This is related to the 4MB / 2MB problem.
MAX_SERVICE_DEPTH 31 <1- What is this?
** building
Hmm.... where is c0? I'm building comp0 as far as I can tell. 
Maybe it's the simple_stklib.o that is manditory... I don't see that error in the make output though.
It exists, and is being built. It's in components/lib
Mayhaps I should not skip over building interfaces entirely.
I think that I sorted the Makefiles correctly.
I don't know what the c.o thing is.
*** interfaces
I need to include at least the interfaces that my components are using. I'm guessing that I will have to add those implementations to the list as well. Let's see what's missing.
sched_hier, stkmgr, sched, pgfault, and cgraph. No idea what these are, but they are missing.
I tried to add stkmgr, hopefully I did. BAM! I did. Who's the man? Right. Calm down. You haven't accomplished anything yet today aside from learning a bit of fucking make.
* <2012-11-12 Mon 12:07> Build problems
** Build c0
According to Gabe, it's built by /components/implementation/Makefile.subsubdir. Back to Makefiles. Yeah!
When I comment out the related line, things seem to build the same. So... maybe it isn't being run?
General confusion about the makefile setup Gabe is using. Makefile.subdir and Makefile.subdirdir are included (as appropriate) for components so that they all have the same make scripts, with the only changes being their dependencies (and described in their local Makefile). It makes perfect sense, but is still a bit confusing.
That seems to have fixed the problem.
** cos_vas_cntl
booter.c:cos_init calls this function, found components/include/cos_component.h.
Not sure what is going on here. The addr argument is attained from round_up_to_pgd_page (in our favorite: consts.h).
vas -> Virtual Address Space
cos___vas_cntl, called by cos_vas_cntl. Can't find it's implementation. Maybe it's a cos syscall?
Hey, I was right: cos_syscall_3(18, int, __vas_cntl, int, op_spdid, long, arg1, long, arg2);
I still can't find the implementation, but there is a related enum in cos_types.h.
So.... it should be getting the 2nd level table entry for round_up_to_pgd_page since these vas's are just those 4MB regions. This is, of course, more difficult now since the 2nd level address now only address 2MBs.
** round_up_to_pgd_page
I need to make sure that this is only used to "round up" an address to it's 2nd level (from bottom) page table.
Used a few times. I will need to probably look into each of these to deal with the 4MB / 2MB problem.
*** ./components/implementation/vas_mgr/simple/vas_mgr.c
Fairly simple, shouldn't be much to change.
Line 116: vas = alloc_page();
This will likely have to change. And all implementing code for alloc_page should be checked.
*** ./components/implementation/no_interface/llboot/booter.c
I don't honestly understand how it is using round_up_to_pgd_page. Oh well.
*** ./components/implementation/no_interface/boot/booter.c
Trick. This is a link to llboot/booter.c. Or vis-versa.
*** ./components/implementation/valloc/simple/valloc.c
Used in __valloc_init().
This will need more investigation, and I'm guess will have to be changed for the 4MB / 2MB problem.
** vas_hell
I will need to find where the vas_cntl functionality is actually implemented.
Perhaps I should have things building first.
** Building
What is wrong now?
Alright. It works fine.. except once I try to build something outside of no_interface.
When I comment out the loop to build all subdirs in Makefile.subdir, it prevents everything in no_interface from being built. It also prevents anything in implementation from being build.
Copy Makefile.subdir, one version for implementation and one for no_interface. Simplest solution I can think of.
Makefiles.
Done with Makefiles!
** Running
First... a restart.
* <2012-11-13 Tue 10:24> Cleaning up
I'm fixing a bunch of warnings. Most of them are in debug prints, but it doesn't hurt.
A few complaints about putting parans around some of the constants.
** pgtbl_vaddr_to_kaddr
Wow... the warnings show a lot of problems here. I will have to check on this when I have everything running again.
What was I thinking here?
They were all print statements, didn't actually do anything (I thought they may have masked out a bit). Probably written in a desparate moment.
** warnings
So... some of these debug print warnings are not all that simple to clean up due to the linux types involved.
Should be using the pte_val like functions for the prints, for now commenting out.
** Build
Finally building correctly. Problems with llboot in no_interface actually having some interfaces. Don't need to build the implemtations for the things it provides, such as sched and pgfault, but they must have their interfaces built.
Restarting.
** ld: initfs.o: No such file: No such file or directory
I now get this with "make init". Apparantly I am not done with the build problems.
Looks like it is built by implementatio/initf/simple. I guess I'll add that to the Makefiles.
That fixed it. I am going to commit now that I finally have the minimal build working.
** ./cos_loader: corrupted double-linked list
Detected by glibc?
So, something in cos_loader is messing up. No real indication as to what.
My guess is something with the pages.
Main component is being called, and it returns. So... do I have invocations working?
Problem in the close function? This is a general function to close a file (such as the aed). 
Wait, maybe not. hijack.c sets the file functions, there is no close, but ther is a release. Which is called.
No... ipc isn't working. Just the main invocation.
The question is: do I figure out the memory cleanup problem, or continue on? Leaning to continuing.
** Refocus
* <2012-11-14 Wed 11:34> Refocus
A few things to tackle, in no particular order. Or at least, I don't know the order yet.
** IPC
I need to figure out how to create a component that then calls another. I'm not quite sure how to do this.
Maybe I should try to just 
** Memory problem (corrupted double-linked list)
** Page Tables
* <2012-11-15 Thu 13:13> IPC
Busy with other things yesterday. Let's see if I can get this rolling today.
** printc
Will probably make life easier to have this working. But will need IPC to work. So... maybe not as helpful in trying to IPC to work. Two birds with one stone? One idiot with bad metaphors?
** First, how do I get code in my component to execute?
Great, pingpong_run.sh doesn't exist anymore. To the git! Oh... it's int the folder "old." Makes sense.
Need to read docs on the runscript.
** Symbol cos_comp_info at address 0x0.
I don't know. My component includes cos_component.h, so I'm not sure why this is a problem. I think I'm going to look at page tables for a while. Seems less bothersome. 
** printc
** ?
gcc cos_component.o yourcomp.o -c -o yourcomp2.o 
./components/lib/cos_component.o
* <2012-11-17 Sat 13:20> The build
I'm doing something wrong when building my component.
cos_loader isn't able to find cos_comp_info, which isn't doesn't even come up in an objdump.
Which I don't understand... I'm including cos_component.h.
** Lost
I am at a complete loss as to why some components (comp0, llboot) are linking fine, but mine is not.
I'm going to try to create a new component, just to see how it goes. Maybe I missed a step.
* <2012-11-20 Tue 14:48> Building
Working on getting a simple component built. I have managed to get it working in 32bit composite, not back to 64.
The problems may have been related to not doing "make init", but I'm not sure why. This was a problem in 32 bit, but may not have been in 64 bit.
I am writing notes on paper, in the white binder. It's probably not a great idea to split them, but I need to have something tactile every once in a while.
* <2012-11-22 Thu 11:24> Stacks
Gabe figured out the problem: linking.
I had commented out code in cos_asm_upcall, which is included in every component.
And it links in cos_component as a library (libcos_component.a). Unless you comment that code out.
So I need to convert that assembly.
** Moving on
Now we are seg-faulting, but not until after c0's main returns.
I think that I am going to ignore this for now, and try to invocations working.
** ENABLE_STACK_MANAGER
I'm confused about this one. There is also a ENABLE_STK def.
It is set in cos_stkmgr_configure.h which has the following comment: 
// Must be 1 or nothing, this is a very fragile system
ENABLE_STK:=${shell grep ENABLE_STACK_MANAGER include/cos_stkmgr_configure.h | awk '{print $$3 }' }
What is all this? I just want a simple stack implementation.
I currently have the stack manager disabled, which is what I want.
Everything seems happy now! Fixed cos_stkmgr_configure.h so that the manager is disabled.
** printc
* <2012-11-23 Fri 14:42> Segfault fixed, invalid pointer found
Not much done yesterday, but it was Thanksgiving. Yesterday and today are like bonus work days.
Too bad I'll be in tomorrow as well trying to get this done. Because I slacked today.
Alright. I need to get rolling. What is something I can do in 15 minutes? What am I doing anyways?
** Seg-Fault
gdb cos_loader
run "c0.o, ;llboot.o, ;james.o, ;print.o, :c0.o-llboot.o;james.o-print.o" ./gen_client_stub
Seg-faulting with 0's for everything. Not super useful.
The problem seems to be in:
*** close(cntl_fd);
Let's see where it is defined. Haven't I looked at this before?
Looks like close(cntl_fd) ends up calling hijack.c:aed_release, which makes sense.
I am seeing an odd error line, but I'm not sure if it is abnormal or I just never noticed before:
segfault at 0 ip (null) sp 00007fffcbefb258 error 14 in cos_loader[400000+d000]
The stack pointer address seems odd. Maybe I am screwing it up somewhere... perhaps in aed_release.
Also, this function gets spit out in a trace: remove_from_page_cache <- in linux source.
*** cos_rdtscll
Five bucks says that this is it.
Hmm... looks like nope.
But it is still wrong. Damnit, how many times is this one function defined?
That was it. Of course. Funny %rsp means you have $%#*&! up some assembly.
** glibc detected 
./cos_loader: free(): invalid pointer: 0x000000000060e030 ***
Seems to be happening while deallocating services.
The problem is cause when the service_symbs struct is being freed.
The address, however, should be valid, and on the heap.
* <2012-11-25 Sun 14:49> Invalid Pointer
Hmm... now we have a seg-fault. Same function though (freeing up service_symbs).
Okay, now we have a seg-fault, but prior to reaching that function.
** Consistent behavior?
Can I at least get it to fail out the same way?
Hmm... looks like the error from before. Did I forget to commit those changes?
Nope, cos_rdtscll fix is there. Just needed to re-make everything.
** 32 bit?
I do not understand why there is such a problem freeing the memeory.
obj is nil...
I think that I'm going to take a look at the 32 bit version, and see what kind of adresses it is spitting out.
From x86_64:
Freeing 0x60e030
         obj: (nil)
         str->exported: 0x60e0b8
         str->undef: 0x6180c8
         str: 0x60e030
//*** glibc detected *** ./cos_loader: free(): invalid pointer: 0x000000000060e030 ***
From x86_32:
obj has an address... I need to figure out where this is being allocated.
* <2012-11-27 Tue 15:17> Invalid Pointer
** Allocation
s: 0x60e030
s->obj 0x643110
So... the service is instantiated, and s->obj is not nil, at least for a bit.
It seems to be correct in the setup_kernel function.
Hmm..... interesting.... something is messing it up. Binary search for error!
*** setup_kernel
It is in this function that something goes wrong.
I'm closing in... either aed_enable_syscalls or close... My bet is on close:
*** close
I was right. Somehow that doesn't make me especially happy. What's wrong with close?
close(), as we have discovered previously, calls: hijack.c:aed_release
*** Pages... again
Found the problem:
      pgd = pgd_offset(composite_union_mm, COS_INFO_REGION_ADDR);
      memset(pgd, 0, sizeof(int));
This is a top level directory, meaning that I am actually unmapping a ton of addresses.
Also the sizeof(int) is wrong.
I will need to come back an clean up this code. It only allows for 2MB of shared memory, instead of 4.
But that is how all of my code is at the moment.
** cos_sched_base.c
I want to get invocations working, but I really don't trust my sample component, so I'm trying out cpu.
This is probably a bad idea... but I'm not even sure if the main method in my component is being called.
Okay, it is not being called. I guess that calling it might be an invocation...
* <2012-11-29 Thu 11:21> Invocation.
This title is losing meaning, since I have used it so much.
How do I make a simple invocation? As far as I can tell my first component is not being called.
But is that an invocation?
** tracing startup
cos_loader calls the comp0.c:spd0_main, which in turn calls main and sched_init
*** main
This is defined in cos_component.c, and is weak, so can be overwritten (although it is not in this case).
Testing... It works! Doesn't do anything, but that is better than breaking.
*** sched_init
Maybe my component is never being scheduled.
I'm not sure why the aed file is being create an then closed... some sort of bootstrapping?
Declared by interface/sched_hier/sched_hier.h, so in this case fulfilled by llboot
Not in booter.c, so must be in cos_asm_scheduler.S, in components/implementation/sched
I'm not sure how that gets linking in.
And yet, still no sched_init.
Where is this code?
**** boot_deps.h
Has a implementation which calls cos_init(). Maybe this is the key.
So comp0 includes sched_hier.h, which declares sched_init, and then llboot provides it through boot_deps.h
Testing... huh. That's weird.
return value is: 1082142752. Or, in hex: 40803020. Looks like an address to me. I was expecting 92.
** Invocation
So, I suppose I have found an invocation that is not working. I guess I should fix that.
I wonder if that address actually had the correct value. May not even be worth checking.
Well, ucap_tbl for c0 happens to be located at 0x40803000. Interesting.
That table would likely have sched_init in it, (ha! init in it), since the table should contain capabilities that it can invoke.
Should be a struct usr_inv_cap
This struct is used in cstub.h, used as an argument for the generated stubs.
Defined in cos_types.h
Should I be looking at the generated stubs?
Can I just use the... I don't know.
I talked to Gabe; he put me back on track
** Comp-to-Kernel
I'm switching to paper notes.
Using print syscall:
  cos_print("In comp0:spd0_main\n", 20);
** /components/lib/c_stub.S
/* All un-implemented */  
Awesome. Time to figure out the conventions.
Or make them up, I guess.
** BASE: Reached Test Function Two! Call IPC 
I'm in the kernel! Awesome. Time to break more things (aka write assembly)
updated c_stub.S
now working on kernel/inv.c:ipc_walk_static_cap
cos: capability 134216261 greater than max from spd 0 @ 4080007b.
* <2012-11-30 Fri 11:06> Enter the Kernel
* <2012-12-03 Mon 11:09> Sigh.
Paper notes.
* <2012-12-04 Tue 14:30>
* <2012-12-06 Thu 11:21> IPC: Part 2
Paper notes.

* Mexico
* <2012-12-19 Wed 14:59> Syscall3
It has been a while, but back at it.
My problems are currently with 3 argument syscalls, which appear to be jumbling up the 3rd arguement.
(llboot calls one of these to do some crap with memory, so I'll have to debug that bit as well, I am sure)
Paper notes.
* <2013-01-04 Fri 11:00>
Just a quick update. I think that I have figure out my troubles.
It is actually the 4th argument (since spdid gets added in as the first).
For the 4th argument, the ABI convention is to use %rcx. The kernel interface, however, uses %r10 (since syscall trashes %rcx, for the return pointer or some such nonsense).
-- Gabe says that someone is rewriting it anyways, so my hack will stand for now.

* <2013-01-08 Tue 10:28> You may find yourself in a strange house
I need to finish Composite. Soon. This is taking forever.
** IPC Path
** Merge HAL
** Complete Page Tables
** PARTY!
** Do Actual Research
* --------------------------------------------------------
* <2013-11-18 Mon 10:55> QEMU
I'm back at it... but the goal is different now.
I need to get some of my Player drivers running in Composite. I think that switching to QEMU may be a worthwhile venture. Unfortunately it means getting composite set up again. But we're sticking with 32bit for now.
** Composite / QEMU
Roughly following: https://help.ubuntu.com/community/Installation/QemuEmulator
*** Install QEMU
*** Download 10.04 32bit ubuntu server edition iso.
*** Setup Disk File
    qemu-img create ubuntu-test 4G
*** Install .iso to the new desk file
I'm having troubles getting QEMU to use IDE instead SCSI
qemu-system-i386 -hda ubuntu-test -cdrom ubuntu-10.04.4-server-i386.iso -m 512 -boot d
qemu-system-i386 -drive file=ubuntu-test,index=0,media=disk,if=ide -cdrom ubuntu-10.04.4-server-i386.iso -m 256 -boot d
I do not know why I was unable to get QEMU to use IDE instead of SCSI, but it doesn't seem to be a problem. SCSI had originally given me trouble with VMware (I was unable to patch the kernel; would fail on reboot, likely had the incorrect drivers), but QEMU handles it fine.
So, to run, use something like (mounts cdrom, but does not boot from it, 512 ram):
qemu-system-i386 -hda ubuntu-test -cdrom ubuntu-10.04.4-server-i386.iso -m 512
*** Install Composite
Get git (and others): sudo apt-get install git-core build-essential ncurses-dev binutils-dev (otherwise no bfd.h)
Now follow the regulare Composite install instructions

* <2013-11-20 Wed 10:30>
I now have Composite running in QEMU, so it is on to getting a Player driver running as a Composite component!
** Driver to Component
Time to figure out how Player / Stage actually runs. Sigh.
Player is the server, controllers are the clients. Drivers run inside of Player.
** Controller to Component
I need to convert libplayerc to work in Composite.

* <2013-11-21 Thu 11:12> libplayerc
For a controller to be run inside a component, I am going to need libplayerc to work in composite.
Not sure what exactly that entails.
** c controller
All of my controllers currently use libplayerc_py (since they are all in python). Unfortunately, Composite doesn't have python support.
Based off of: http://playerstage.sourceforge.net/doc/Player-svn/player/group__libplayerc__example.html
*** Run c controller on linux system
Right now I'm building with pkg-config, will need to change that.
Great... run_player.py needs to be updated.
That took way too long. But run_player.py has been fixed and I have a basic controller. The good news is that it doesn't require stdio.h (was just there for printf).
** libplayerc
I need to have libplayerc building in composite, and to know what that actually means.
I suppose that libplayerc will be a component?
Nifty, Gabe post a guide to porting existing programs to the google group.
The following are my execution of the steps he outlined
*** Statically link example program.
Using `strace` to run the example program, I see that there are calls to mmap, but I don't know if that is for libplayerc.
`nm` shows that there are undefined lines to libplayerc functions. Lame.
**** Statically link libplayerc
Easy! Just had to turn of the option to build them as shared.
Actually... compile error: usr/bin/ld: ../../../../libplayerinterface/libplayerinterface.a(playerxdr.o): relocation R_X86_64_32 against `xdr_player_devaddr_t' can not be used when making a shared object; recompile with -fPIC
Disabled the python bindings. That did the trick.
**** Build basic controller
This is throwing a ton of errors, because libplayerc.a still has a ton of undefined symbols.
Each device seems to have a slew of similar ones. For example, dev_simulation.o has a table like:
dev_simulation.o:
                 U free
                 U malloc
                 U memcpy
                 U player_simulation_pose2d_req_t_free
                 U player_simulation_pose3d_req_t_free
                 U player_simulation_property_req_t_free
                 U playerc_client_request
                 U playerc_client_write
                 U playerc_device_init
                 U playerc_device_subscribe
                 U playerc_device_term
                 U playerc_device_unsubscribe
0000000000000000 T playerc_simulation_create
00000000000000d1 T playerc_simulation_destroy
000000000000027c T playerc_simulation_get_pose2d
0000000000000431 T playerc_simulation_get_pose3d
000000000000062e T playerc_simulation_get_property
0000000000000208 T playerc_simulation_get_time
0000000000000743 T playerc_simulation_pause
0000000000000133 T playerc_simulation_putmsg
0000000000000775 T playerc_simulation_reset
free, malloc, and memcpy are probably handled by dietlibc (I'll deal with that next).
playerc_client_request is in almost all devices. So, how do I build the devices statically?
* <2013-11-25 Mon 13:08> build static libplayerc
Still working on the libplayerc static library.
I am now building every required c file into an object file (no linking). I will then try to link all of them together as a static library.
rpc/xdr.h should be dietlibc.
Not surprisingly, functiontable.o has many missing references...

I don't know for sure... but now that I think about it, it doesn't seem like it would be possible to... hm.
Wow, okay, looks like this might actually work.... I am suspicious. Down to 27 undefined references.
Alright, well... looks like that is actually working. 
But just for client.a
Every single file is compiled by itself statically (with gcc -c). Then ld can be used to tie them all together. Still undefined symbols for glibc things.
So, libplayerc just needs client and 50 other files. Fuck.
I think that I am going to need to make a separate source repo, with its own make files. Alternatively I could learn how to use CMake.
* <2013-12-02 Mon 13:14> static libplayerc
I'm going to create a new git repo for the static libplayerc build. Seems like the best solution. That way I can create my own set of Makefiles.

* <2013-12-04 Wed 14:10> libplayerc dietlibc
Previous step was successful. I now have a repo of Make files which will copy over the needed Player files, and then build libplayerc.a as a static library.
The next step is switching glibc for dietlibc.
Oh right... still a few unresolved refs.
Well, went ahead with dietlibc anyways; install with sudo apt-get, then just see CC to "diet gcc -nostdinc" in Makefile.variable (oh, and use $(CC) everywhere instead of gcc).
__you_tried_to_link_a_dietlibc_object_against_glibc <- Seems like a problem.
So, that is a symbol in the new object's symbol table. It is there so that LD can throw an error later if you try to link a dietlibc object to glibc.
** zlib.h dev_map.o
dev_map is not building: dev_map.c:49:20: fatal error: zlib.h: No such file or directory
The question is if I should try to fix this at all. Will dev_map be used on the Composite side?
Skipping for now.
** Linking
Apparently you need to link the required libraries AFTER the objects that need them.
* <2013-12-05 Thu 10:01> libplayerc dietlibc missing maths
A good deal of the undefined refs are math functions, such as sin, cos, floor and fmod.
I can't ignore them, since client.c is missing a few.
** SHIT. x86_64 dietlibc
I just realized that I am using the x86_64 version of dietlibc. That probably will not work in composite.
Make that; it will definately not work in composite.
Oh right... I need to compile everything for 32 bit.
Rebuilding dietlibc now with 'make i386'
Added -m32 to my Makefiles CFLAGS
*** /usr/bin/ld: cannot find -lgcc dietlibc
sigh.
Fixed. Missing dependency: libc6-dev-i386 
** incompatible with i386:x86-64 output
LD needs to be told which format to output. Used the flag -melf_i386
Check supported emulations: ld -V
** Undefined refs
Well... sin and cos are no longer absent. Odd.
Missing are some xdr refs like xdr_longlong_t (hmm... 64 bit that one?), jpeg_decompress, and player_wkb_create_processor
*** xdr_longlong_t
xdr stands for External Data Representation. Some sort of network serialization standard. Good to know.
hm.... rebuild player 32 bit?
longlong is only used byt player_health_memory_t and player_simulation_time_req_t (which I made)
I should probably just modify those interfaces.
**** player_simulation_time_req_t
In player/libplayerinterfaces/interfaces/031_simulation.def
Hopefully this doesn't have to be larger than 32 bit.
**** xdr_player_health_memory_t
This doesn't seem like the correct way to go about things...
There ought to be a way for longlongs to be used on 32 bit machines...
Maybe it is time to look at the xdr gen scripts.
uint64 may be an alternative.
uint64_t worked... I just replaced the int64_t with it in the offending interfaces. I think that unsigned is more appropriate for all of them anyways.
*** jpeg_decompress
used by dev_camera.o ... getting rid of it.
*** player_wkb_destroy_processor / create
used by dev_vectormap.o ... getting rid of it.
*** fputs
Library link order; moved dietlibc.a to the end
*** __umoddi3 / __udivdi3
eh? Okay, so these are generated by the compiler (maybe?) to deal with 64 bit arithmatic on a 32 bit machine.
So, probably an issue with the dietlibc build.
I'm giving up for the day.

* <2013-12-06 Fri 11:46> Nothing
I got nothing done today. Late start followed by office hours, grading, and an early finish.
** __umoddi3
This might get ugly. It is defined in libgcc.a.
The bad news is it is likely that libgcc.a has undefined refs or links to libc (which is problematic, since I am replacing libc with dietlibc).
One option may be to simply copy the umoddi3 and udivdi3 code over. Hopefully it is not too complicated (or links).


* USEFUL Things.
** bash
Last entered command: !!
Open a file that was found with your previous find command: emacs -nw `!!`
Last entered arugument: $_
** debuging, asm
Fail out (so that registers can be examined:
    xor %rdi, %rdi
    call *%rdi 
** find
> find . -name "*.c" -o -name "*.h"
> find . -name "*.h" -exec grep -n "pte_t" {} \;
  -o does not seem to work with -exec

** gcc, usefull flags
  compile into assembly (no linking) > -S
  compile into an object file (library) > -c
  add link / include path > -L / -I (each entry must be with separtate -I / -L)
  define a variable (same as #define) > -D Name=Value (-D Name is sufficient for #ifdef)
** GDB commands
You can add breaks at a label
> break label_name
Step next, into, and finish
> n > s > finish
> tui reg general
> frame
> x 0x_______ (look at the stack pointer)

** git commands
> git log
> git show --name-only
Create a patch

To apply it, try
> git am --whitespace=fix name.patch
When that doesn't work:
> git apply --reject --whitespace=fix name.patch
Fix the problems (look for filename.ext.rej files)
Add the modified files, then
> git am --resolved

Create / Delete branch
> git branch name / git branch -D name
Change branch
> git checkout name
Merge branch
> git merge name

** inline assembly
r for any register?
*** Register Constraints
=A - in x86_32, this refers to the pair eax and edx, so can not be used in x86_64
** Job Management
^z - background / fg - foreground
kill %1 - kill first job listed (jobs)
** Kernel, adding driver
find the .config file, in the source for the kernel you download. Go there.
Backup the .config
> make menuconfig  <- menu based config editor
> make 
> make modules
> sudo make install
> sudo make modules_install
> sudo mkinitramfs -o /boot/initrd.img-2.6.36 2.6.36
> sudo update-grub
Restart. Obviously the image name may be different.
** networking
To restart, run following as root
> /etc/init.d/networking restart
*** If networking isn't working at all:
And ifconfig isn't showing the device (eth0)
Check if the hardward exists
> lspci
If the hardware is there, then the problem is likely a missing driver.
See adding drivers to kernel.
** objdump
  Print out symbol table > -t 
** org-mode
Date and Time stamp
  ^u+^c+.
** tar / gzip
tar and gzip a folder:
> tar -zcvf folder_name.tar.gz folder
** tmux
Create Window
  ^b+c
Rename Window
  ^b+,
Kill Current Pane | Window
  ^b+x
Split Horizontal / Vertical
  ^b+" / ^b+%  
Scroll terminal / exit
  ^b+[ / q
Rotate panes
  ^b+^o
* Assembly Conventions
** Composite Syscall
| x86_32 | x86_64 | Purpose    |
|--------+--------+------------|
| eax    | rax    | sys_offset |
| edx    | rdi    | spd_id     |
| ebx    | rsi    | arg0       |
| esi    | rdx    | arg1       |
| edi    | r10    | arg2       | << rcx? Better not, clobbered by syscall... actually... rbx?
| ecx    | r8     | ret_ip     |
| ebp    | r9     | ret_esp    | 
** Composite IPC
| x86_32 | x86_64 | Purpose |
|--------+--------+---------|
| eax    | rax    | cap_#   |
| ebp    | r9     | sp      |
| ecx    | r8     | ip      |
| ebx    | rsi    | arg0    |
| esi    | rdx    | arg1    |
| edi    | r10    | arg2    |
| edx    | rdi    | arg3    |
** syscall
Clobber rcx, r11
%rax has the syscall number
Kernel interface uses %rdi, %rsi, %rdx, %r10, %r8, %9
** sysenter
** x86_64 call

* Todo
** Look at hw_ints.c
Change how it inserts the composite syscall code,
line 140:  wrmsr(MSR_IA32_SYSENTER_EIP, (int)handler, 0);
** cos_component.h
Has the system call stubs. Need to change the inline assembly over

** composite_call_ipc
In ipc64.S

** composite_ret_ipc
** c_stub.S
** cos_types.h
Has some types defined, but then uses some "standard" types. 
Not sure if it will be a problem.

** debug c print code
Right now test_print_reg in entry.c clobbers a bunch of registers.
It would be easier to debug if that wasn't the case. But it may not be worth the effort.
Could just define a macro to do.

** fix cos_print
It should make use of the length value, or get rid of it.
** The rest of the syscalls
** In ipc64.s:composite_make_syscall
How come the stack manipulation code is no longer needed? Because I don't clobber registers?
Will this be needed again? For example, to ensure that an interupt mid-syscall doesn't clobber the regs?
%rcx may be clobbered by syscall as it is. It's the 3rd argument, which I haven't used yet. I really should check that.

** Stacks
Check in /component/lib for a bunch of stack management code that will need to be converted.

** dietlibc
/components/Makefile.comp should select the correct DIETBIN directory.
Either bin-i386 or bin-x86_64
** component includes
See 9-24

** Finish conventions table
** Fix c_stub.h
I got rid of the whole error code returning thing.
Also, I probably broke it.
** Memory management
   Fix vas_mgr and valloc
** shared_region_pte
Fix james_page0 and james_page1 and how they are allocated
** Hardware Abstraction Layer

** Fix page table abstraction
   Start with hpage_index(). It is brain-dead the way I have it working now.
** VAS stuff (memory, 4MB / 2MB)
   Take a look at <2012-11-12 Mon 12:07> 
** Test consts.h macros
Make sure that everything that should be an unsigned long is, especially constants. 
For example, round_to_pow2 needs to be checked and tested.
** page_tables.c
Clean up, and fix things like copy_lvl2_range
Oh yeah, don't forget hijack.c:aed_release()

* Emails
** <2012-10-14 Sun 15:31> Gabe
James,
For all of this page-table stuff, the best way to think about them is from the software structure's perspective.  The hardware requires that the page-tables are laid out a specific way.  So when you look at some code like this, the important thing is to map the code back to what should be happening to the underlying data-structure.  Here's the old article on the initial support for 4-level page-tables:  http://lwn.net/Articles/117749/.
If the pmd is empty, that means that there is no page table that continues at that point (i.e. the leaf for that address is not a page to be mapped into the address space).
So, as you said, we need to add in a page middle directory at that location.  After we've done that, much of the previous code should modify that pmd, and will need to change to reflect the fact that we're now mapping 2MB regions instead of 4MB regions for each of the entries in the pmd.  I'd simply make it so that each component uses up two pmd entry so that we still maintain 4MB component regions by default.  Ignoring this annoying 2MB/4MB thing (i.e. the # of entries per page in the page table), I think that a lot of the code will change to making changes to the pmd rather than what is happening in the code now, the pgd.  We're on the same page with this; this is what you said below.
So how do you get a PMD?  Allocate a page from the Linux kernel (e.g. this is done when you create a spd), and set the pud in the appropriate location to point to the physical address of the page.  Set up the bits correctly in the pud so that the page is "present, and read/writable", and make sure that (initially) the page is zeroed out.  Now we can add entries into that page, and we will be creating ptes that will be set to point to the pages themselves.
When we create a new spd, we will get a new page table through the normal mechanisms, add in the pud (if required), add in the pmd, and then go from there.  In the current code, we allocate the pgd, and the pte.  That's it.   So there are more page allocations, and they need to be carefully placed into the page tables.
I'd like to remind you again though, that you don't really need page tables to be set up if you are never switching into the destination component.  For the IPC path, the first draft won't include that.  However, this is a problem we'll have to solve sometime, so if you'd prefer to do it now, that's fine.

Hope that helps???

Best,
Gabe

On Sun, Oct 14, 2012 at 2:18 PM, James Marshall <jcmarsh@gwmail.gwu.edu> wrote:
Okay, I think that I am starting to understand the problem. I haven't gotten to dealing with spds yet, because I am trying to fix this line first:
https://github.com/gparmer/Composite/blob/master/src/platform/linux/modonlyonlyule/hijack.c#L1948
Here, the pte for the shared region is being placed directly into a pgd, which is not suitable in 64 bit (I think that my system is actually using 4 level tables, but that shouldn't be any more difficult than 3 levels).
I am able to "walk" the page tables using code such as the following:
       pgd = pgd_offset(current->mm, COS_INFO_REGION_ADDR);
        if (pgd_none(*pgd) || pgd_bad(*pgd)) {
                printk("Could not get pgd_offset.\n");
                return -EFAULT;
        }
        pud = pud_offset(pgd, COS_INFO_REGION_ADDR);
        if (pud_none(*pud) || pud_bad(*pud)) {
                printk("Could not get pud_offset.\n");
                return -EFAULT;
        }
        pmd = pmd_offset(pud, COS_INFO_REGION_ADDR);
        if (pmd_none(*pmd) || pmd_bad(*pmd)) {
                printk("Could not get pmd_offset.\n");
                return -EFAULT;
        }
        pte = pte_offset_kernel(pmd, COS_INFO_REGION_ADDR);
        if (pte_none(*pte)) {
                printk("Could not get pte_offset.\n");
                return -EFAULT;
        }

From how I understand it, I should then just be inserting the pte into the pmd (instead of the pgd). The problem is that when I walk the page tables, pmd_offset fails.
So, do I need to allocate a pmd at this point? Or copy it from the struct_mm in which the shared region pte was originally mapped? 
Do you know of any good references for messing around with the linux page tables? The best I have found is from Gorman: http://kernel.org/doc/gorman/html/understand/understand006.html. Unfortunately it doesn't explain how to manipulate the tables, just walk them.

Thanks,
James
